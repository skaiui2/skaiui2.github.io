<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Sparrow拓展篇 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Sparrow拓展篇</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Sparrow拓展篇</h1><div class="post-meta">2024-11-08</div><div class="post-content"><p>skaiuijing</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在笔者更新完Sparrow手把手教学系列后，原本是不打算继续更新的。但关于Sparrow系列的读者又渐渐增多，作为作者，总感觉这个系列的文章还是稍微有些不圆满，恐怕多少会让读者有些意兴阑珊。</p>
<p>最近又恰好有一点空闲时间，思来想去，于是决定再更上这么一篇，作为Sparrow系列的补充。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="对调度层进行抽象"><a href="#对调度层进行抽象" class="headerlink" title="对调度层进行抽象"></a>对调度层进行抽象</h3><p>Sparrow并没有IPC机制，虽然也可以作为一个内核，但是感觉还是有点残缺。于是作为拓展，笔者决定对Sparrow内核的调度层进行抽象，先引入任务状态，这样就可以对调度层进行封装与抽象了。<strong>调度层负责提供线程状态转移的接口，IPC层则利用接口完成线程间的通信。</strong></p>
<p>为了规范抽象层，必须要对任务的状态进行定义：</p>
<p><strong>线程的状态</strong></p>
<p>Sparrow中，任务有五种状态：<strong>运行态、就绪态、延时态、阻塞态、挂起态</strong></p>
<p>运行态：任务正在运行，毫无疑问，处在运行态的任务只有一个。当任务处于运行态时，它也处于就绪态。</p>
<p>就绪态：任务可能在运行，也可能准备运行，当任务处于就绪态时，它可能处于运行态（如果它是最高优先级任务的话）。<strong>只有就绪态中的任务会被执行。</strong></p>
<p>延时态：任务正在延时中，当任务处于延时态时，它还可能处于阻塞态。例如一个任务正在等待一个事件的发生，任务的等待最长时间是100ms，如果事件一直不发生，那么任务就会等完100ms，如果在这个过程中事件发生了，任务会马上执行。在这种情况下，任务既处于延时态，又处于阻塞态。</p>
<p>阻塞态：任务正在等待某个事件的发生，此时任务也可以处于延时态。</p>
<p>挂起态：当任务很长时间都不需要紧急执行时，可以把该任务挂起。当然，不止挂起任务，也可以挂起调度器。挂起态通常是手动设置的，这取决于用户对任务的管理。</p>
<h3 id="修改Sparrow代码匹配抽象层"><a href="#修改Sparrow代码匹配抽象层" class="headerlink" title="修改Sparrow代码匹配抽象层"></a>修改Sparrow代码匹配抽象层</h3><h4 id="查找任务"><a href="#查找任务" class="headerlink" title="查找任务"></a>查找任务</h4><p>由于Sparrow最大支持32个任务，通常使用一个uint32_t变量的各个位表示任务的状态，因此快速查找任务成为了一个难题，不过我们已经实现了相关函数FindHighestPriority，对其进行简单修改，传入参数从而找到最优先的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__attribute__( ( always_inline ) ) static inline uint8_t FindHighestPriority( uint32_t Table )</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t temp,TopZeroNumber;</span><br><span class="line">    __asm volatile</span><br><span class="line">            (</span><br><span class="line">            &quot;clz %0, %2\n&quot;</span><br><span class="line">            &quot;mov %1, #31\n&quot;</span><br><span class="line">            &quot;sub %0, %1, %0\n&quot;</span><br><span class="line">            :&quot;=r&quot; (TopZeroNumber),&quot;=r&quot;(temp)</span><br><span class="line">            :&quot;r&quot; (Table)</span><br><span class="line">            );</span><br><span class="line">    return TopZeroNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然有了这个函数，那么我们可以修改时钟检查函数，当然，由于Sparrow支持的任务数量毕竟小，可能对性能的提升不大。</p>
<p><strong>修改代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void CheckTicks( void )</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t LookupTable = Delay;</span><br><span class="line">    TicksBase += 1;</span><br><span class="line">    if( TicksBase == 0)&#123;</span><br><span class="line">        TicksTableSwitch( );</span><br><span class="line">    &#125;</span><br><span class="line">    //find delaying Task</span><br><span class="line">    while(LookupTable != 0)&#123;</span><br><span class="line">        uint8_t i = FindHighestPriority(LookupTable);</span><br><span class="line">        LookupTable &amp;= ~(1 &lt;&lt; i );</span><br><span class="line">        if ( TicksBase &gt;= WakeTicksTable[i] ) &#123;</span><br><span class="line">            WakeTicksTable[i] = 0;</span><br><span class="line">            Delay &amp;= ~(1 &lt;&lt; i);//it is retained for the sake of specification.</span><br><span class="line">            Ready |= (1 &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    switchTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装与接口，就是为每个模块定义清晰的接口），这些接口描述了模块的输入、输出和预期行为。接口应尽量简洁，隐藏模块内部的实现细节。将具体实现封装在模块内部，通过接口暴露功能。实现应尽量保持私有性，避免外部直接访问内部细节。</p>
<p><strong>添加抽象层</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//The abstraction layer of scheduling !!!</span><br><span class="line">uint32_t StateAdd( TCB_t *self,uint32_t *State)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t xre = xEnterCritical();</span><br><span class="line">    (*State) |= (1 &lt;&lt; self-&gt;uxPriority);</span><br><span class="line">    xExitCritical(xre);</span><br><span class="line">    return *State;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint32_t StateRemove( TCB_t *self, uint32_t *State)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t xre1 = xEnterCritical();</span><br><span class="line">    (*State) &amp;= ~(1 &lt;&lt; self-&gt;uxPriority);</span><br><span class="line">    xExitCritical(xre1);</span><br><span class="line">    return *State;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t CheckState( TCB_t *self,uint32_t State )// If task is the State,return the State</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t xre2 = xEnterCritical();</span><br><span class="line">    State &amp;= (1 &lt;&lt; self-&gt;uxPriority);</span><br><span class="line">    xExitCritical(xre2);</span><br><span class="line">    return State;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// the abstraction layer is end</span><br></pre></td></tr></table></figure>

<p>同时支持挂起调度器，如果<strong>空闲任务进入了挂起态，代表挂起调度器</strong>（因为空闲任务通常是进入低功耗，是为了防止单片机无事可做而衍生出来的任务），修改SysTick_Handler如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void SysTick_Handler(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t xre = xEnterCritical();</span><br><span class="line">    uint32_t temp = Suspend;</span><br><span class="line">    temp &amp;= 1;// If the idle task is suspended, the scheduler is suspended</span><br><span class="line">    if(temp != 1) &#123;</span><br><span class="line">        CheckTicks();</span><br><span class="line">    &#125;</span><br><span class="line">    xExitCritical(xre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>修改命名</strong></p>
<p>将状态表修改如下,这样更符合接口的原则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint32_t Ready = 0;</span><br><span class="line">uint32_t Delay = 0;</span><br><span class="line">uint32_t Suspend = 0;</span><br><span class="line">uint32_t Block = 0;</span><br></pre></td></tr></table></figure>



<p>现在，我们对调度层的抽象已经基本完成了，是时候引入IPC机制了。</p>
<h2 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>笔者第一个引入Sparrow的IPC机制是信号量，它是由Dijkstra大神（Dijkstra算法、三色标记和并行垃圾回收算法等等算法的提出者）发明的。</p>
<p>信号量的出现是在Dijkstra的一篇文章中，有趣的是，文章的内容是关于一个叫THE的操作系统，基于一组并发进程，这些并发进程通过一种名叫信号量的机制相互同步并且与硬件同步。不得不说，信号量的思想真的是太精妙了。</p>
<h4 id="初始化时的值不同，功能不同"><a href="#初始化时的值不同，功能不同" class="headerlink" title="初始化时的值不同，功能不同"></a>初始化时的值不同，功能不同</h4><p>信号量有两种功能，一种是互斥，另一种是条件同步，决定信号量的功能的关键在于它初始化时的值。</p>
<h4 id="初始化为1，互斥功能"><a href="#初始化为1，互斥功能" class="headerlink" title="初始化为1，互斥功能"></a>初始化为1，互斥功能</h4><p>据笔者所知，2.6.9版本linux内核中，几乎所有的信号量（互斥锁、自旋锁）都是用于互斥，也就是对某个资源的独占访问。</p>
<p>用于互斥时，使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock.semtake(上锁)</span><br><span class="line">访问资源</span><br><span class="line">lock.semrelease（解锁）</span><br></pre></td></tr></table></figure>

<p>当然，简单的信号量会导致<strong>优先级反转</strong>现象，所以必须使用<strong>优先级继承</strong>等方法实现<strong>互斥锁</strong>，这样就能确保万无一失。</p>
<h4 id="初始化为0，同步功能"><a href="#初始化为0，同步功能" class="headerlink" title="初始化为0，同步功能"></a>初始化为0，同步功能</h4><p>有时候，我们往往会设置一个条件变量，当变量触发时，任务内部的代码才会执行，这同样可以通过信号量实现。</p>
<p>使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">taskA()</span><br><span class="line">&#123;</span><br><span class="line">	释放信号量</span><br><span class="line">	semrelease()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taskB()</span><br><span class="line">&#123;	没信号量，继续阻塞</span><br><span class="line">	semtake()有信号量了，不阻塞了，任务往下执行</span><br><span class="line">	执行内部代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="信号量的操作"><a href="#信号量的操作" class="headerlink" title="信号量的操作"></a>信号量的操作</h3><p>信号量有P和V两种操作，也叫down和up操作。</p>
<p>P操作：如果信号量的值大于1，就减1，并允许任务继续执行，否则阻塞任务。</p>
<p>V操作：对信号量的值加1，如果有任务在等待这个信号量，就唤醒它。</p>
<p>学会了信号量，一般RTOS的IPC机制基本都学会了，这也就是笔者为什么给Sparrow引入信号量的原因。</p>
<h2 id="代码实现信号量"><a href="#代码实现信号量" class="headerlink" title="代码实现信号量"></a>代码实现信号量</h2><p><strong>P操作是获取信号量，V操作是释放信号量，这么一对照，代码就显而易见了。</strong></p>
<p>顺便一提，FreeRTOS的信号量是基于队列机制实现的，导致有很多人认为信号量是队列的一种，说实话，笔者很纳闷，这种说法明显是错误的，为什么会流行呢？难道因为一个正方形是由两个三角形组成的，你就认为三角形是正方形的一种吗？还有把信号量看作长度为某个值的消息队列的说法，这些都让笔者感到匪夷所思：FreeRTOS的消息队列就是利用了发送消息和接受消息时的计数来创建信号量的，根本不会开辟内存空间，没有长度这一说法。（不得不说互联网上很多资料漏洞百出，不仅没有帮助作用，反而误导了不少读者）</p>
<h4 id="调度层抽象的应用"><a href="#调度层抽象的应用" class="headerlink" title="调度层抽象的应用"></a>调度层抽象的应用</h4><p>有意思的是阻塞和延时的实现，由于我们已经对调度层进行了抽象和封装，对任务状态的转化通过StateRemove和StateAdd接口进行，其实这是很简单的封装，所以读者可能没什么感觉，甚至觉得在画蛇添足。这是因为Sparrow太小了，但是，如果项目非常庞大，建立一层抽象是非常有必要的。笔者只是为读者展示如何建立一层简单的抽象来规范代码。</p>
<h4 id="线程状态的改变"><a href="#线程状态的改变" class="headerlink" title="线程状态的改变"></a>线程状态的改变</h4><p><strong>semaphore_take获取信号量时，如果没有信号量，那么线程的状态转变为阻塞态和延时态。</strong></p>
<p><strong>semaphore_release释放信号量时，如果有线程因为该信号量阻塞，那么线程的状态从阻塞态和延时态中移除，并转变为就绪态。</strong></p>
<p>当延时结束或者阻塞被唤醒时，线程会继续执行。</p>
<p>为了防止任务没有进行调度就往下执行，笔者建立了一个空循环，PendSV是标志位，如果调度没发生，那么就会慢慢等。</p>
<p><strong>获取信号量的两种结果</strong></p>
<p>1.释放信号量时被唤醒</p>
<p>此时线程的状态从阻塞态和延时态中移除，并转变为就绪态。说明此时信号量可用，可以执行获取信号量的操作。</p>
<p>2.任务超时</p>
<p>此时线程的状态从延时态中移除，但是阻塞态并没有移除，需要被移除阻塞态。同时说明等了半天信号量都不能用，只能返回错误。</p>
<p><strong>通过调度层提供的接口，判断任务的状态，可以得到是哪一种结果，并改变对应的状态。</strong></p>
<p>由于每个任务可能阻塞在不同的信号量上，因此不能都使用总的阻塞表，每个任务都需要有自己的阻塞表，但同时需要更新总阻塞表，<strong>这是一种状态转移的规范。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Class(Semaphore_struct)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t value;</span><br><span class="line">    uint32_t Block;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Semaphore_struct *semaphore_creat(uint8_t value)</span><br><span class="line">&#123;</span><br><span class="line">    Semaphore_struct *xSemaphore = heap_malloc(sizeof (Semaphore_struct) );</span><br><span class="line">    xSemaphore-&gt;value = value;</span><br><span class="line">    xSemaphore-&gt;Block = 0;</span><br><span class="line">    return xSemaphore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void semaphore_delete(Semaphore_struct *semaphore)</span><br><span class="line">&#123;</span><br><span class="line">    heap_free(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t semaphore_release( Semaphore_struct *semaphore)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t xre = xEnterCritical();</span><br><span class="line"></span><br><span class="line">    if (semaphore-&gt;Block) &#123;</span><br><span class="line">        uint8_t i =  FindHighestPriority(semaphore-&gt;Block);</span><br><span class="line">        StateRemove(TcbTaskTable[i],&amp;semaphore-&gt;Block);</span><br><span class="line">        StateRemove(TcbTaskTable[i],&amp;Block);// Also synchronize with the total blocking state</span><br><span class="line">        StateRemove(TcbTaskTable[i],&amp;Delay);</span><br><span class="line">        StateAdd(TcbTaskTable[i], &amp;Ready);</span><br><span class="line">    &#125;</span><br><span class="line">    semaphore-&gt;value++;</span><br><span class="line">    switchTask();</span><br><span class="line"></span><br><span class="line">    xExitCritical(xre);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t semaphore_take(Semaphore_struct *semaphore,uint32_t Ticks)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t xre = xEnterCritical();</span><br><span class="line"></span><br><span class="line">    if( semaphore-&gt;value &gt; 0) &#123;</span><br><span class="line">        semaphore-&gt;value--;</span><br><span class="line">        switchTask();</span><br><span class="line">        xExitCritical(xre);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(Ticks == 0 )&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint8_t volatile temp = PendSV;</span><br><span class="line">    if(Ticks &gt; 0)&#123;</span><br><span class="line">        StateAdd(pxCurrentTCB,&amp;Block);</span><br><span class="line">        StateAdd(pxCurrentTCB,&amp;semaphore-&gt;Block);</span><br><span class="line">        TaskDelay(Ticks);</span><br><span class="line">    &#125;</span><br><span class="line">    xExitCritical(xre);</span><br><span class="line"></span><br><span class="line">    while(temp == PendSV)&#123; &#125;//It loops until the schedule is start.</span><br><span class="line"></span><br><span class="line">    uint32_t xReturn = xEnterCritical();</span><br><span class="line">    //Check whether the wake is due to delay or due to semaphore availability</span><br><span class="line">    if( CheckState(pxCurrentTCB,Block) )&#123;//if true ,the task is Block!</span><br><span class="line">        StateRemove(pxCurrentTCB,&amp;semaphore-&gt;Block);</span><br><span class="line">        StateRemove(pxCurrentTCB,&amp;Block);</span><br><span class="line">        xExitCritical(xReturn);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        semaphore-&gt;value--;</span><br><span class="line">        switchTask();</span><br><span class="line">        xExitCritical(xReturn);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>调度层的抽象和IPC机制中最经典的信号量机制已经介绍完毕，笔者就介绍这么多。只要搞定了信号量，其他的的IPC机制都大差不差，读者甚至可以根据需求自己定制IPC机制，比如：信号量的同步都是一个又一个的同步，有没有办法让一个信号量的释放同步多个任务呢？当然可以，只要在信号量的基础上简单修改为唤醒所有阻塞事件就行。这其实跟linux内核中的completion机制非常相似。</p>
<p>笔者希望读者能动手自己完成消息队列、互斥锁、事件等IPC机制，在Sparrow系列的学习中能够学有所获。</p>
<p>所以剩下的IPC机制笔者就懒得敲了(￣_,￣ )，这是留给读者自己的拓展！就像苏格拉底所说，除了你自己，没有人能够教会你知识，其他人只能激发你的知识！</p>
<p>Sparrow系列的文章一般都是一边是算法思路，一边是代码，而且代码里往往没什么注释，因为笔者并不希望读者看代码看半天，而是希望读者动手敲起来，然后进行代码的调试，通过代码来理解算法的思路。</p>
<p>综上，Sparrow拓展篇结束！o(￣▽￣)ｄ</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RTOS/" rel="tag">RTOS</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/11/20/Sparrow%E6%8B%93%E5%B1%95%E7%AF%87%E4%BA%8C/">Sparrow拓展篇二</a><a class="next" href="/2024/11/04/%E4%BF%A1%E5%8F%B7%E9%87%8F/">信号量</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/compiler/" style="font-size: 15px;">compiler</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/RTOS/" style="font-size: 15px;">RTOS</a> <a href="/tags/TCP-IP-stack/" style="font-size: 15px;">TCP/IP stack</a> <a href="/tags/UDP/" style="font-size: 15px;">UDP</a> <a href="/tags/C-language/" style="font-size: 15px;">C language</a> <a href="/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/" style="font-size: 15px;">虚函数表</a> <a href="/tags/c-flow/" style="font-size: 15px;">c flow</a> <a href="/tags/linux-kernel/" style="font-size: 15px;">linux kernel</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 15px;">内存</a> <a href="/tags/Embedded-RTOS/" style="font-size: 15px;">Embedded RTOS</a> <a href="/tags/c-language/" style="font-size: 15px;">c language</a> <a href="/tags/C-lauguage/" style="font-size: 15px;">C lauguage</a> <a href="/tags/compilers/" style="font-size: 15px;">compilers</a> <a href="/tags/data-struct/" style="font-size: 15px;">data struct</a> <a href="/tags/ble/" style="font-size: 15px;">ble</a> <a href="/tags/IP/" style="font-size: 15px;">IP</a> <a href="/tags/cortex-A7/" style="font-size: 15px;">cortex A7</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/16/ebpf%E6%8A%80%E6%9C%AF/">ebpf技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/21/armCA7%E8%99%9A%E6%8B%9F%E5%8C%96/">armCA7虚拟化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/14/cortex-A7%E6%9E%B6%E6%9E%84/">cortex-A7架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/14/%E5%9C%A8imx6ull-cortex-A7-%E4%B8%8A%E8%BF%90%E8%A1%8CSKRTOS/">在imx6ull(cortex-A7)上运行SKRTOS</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/27/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/">代码设计:面向对象和模块化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/24/buf%E7%BB%93%E6%9E%84/">buf结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/17/IP%E5%8D%8F%E8%AE%AE/">IP协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/08/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/05/%E8%93%9D%E7%89%99%E6%9C%8D%E5%8A%A1/">蓝牙服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/19/TCP%E5%8D%8F%E8%AE%AE%E4%B8%80/">TCP协议一</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>