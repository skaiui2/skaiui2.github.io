<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>C4编译器源码解析 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C4编译器源码解析</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C4编译器源码解析</h1><div class="post-meta">2024-12-11</div><div class="post-content"><p>skaiuijing</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当年在github上有一个非常火的项目，名字叫做c4，有上万star。它是一个c语言的编译器，只用了五百行代码，就实现了编译器自举，可以说是非常厉害。</p>
<p>C4编译器实际上是一个非常小型的编译器，是一个学习编译原理的好素材，它实现了一个简单的 C 语言子集，包含前端和后端，最让人惊艳的就是它能够自举。</p>
<p>其实c4或许称之为解释器更合适。不过无所谓，打个比方，如果说编译器是做一大桌菜然后开吃，那么解释器就是边做菜边吃，这么一看，反正都是吃！（&gt;&lt;）</p>
<p>好吧，开个玩笑而已。</p>
<p>还是让笔者简单介绍编译器与解释器的概念，然后再介绍一下c4的整体设计吧。</p>
<h2 id="编译器与解释器"><a href="#编译器与解释器" class="headerlink" title="编译器与解释器"></a>编译器与解释器</h2><p>编译器是通过翻译的方式阅读程序并且生成对应平台上的程序，对应的平台根据生成的程序执行对应的操作。</p>
<p>解释器是通过解析源程序的每一个输入并转换为对应平台的指令来执行对应的操作。</p>
<p>不过两种方法并没有高低之分，编译器生成的程序的效率更高，解释器生成的程序更容易排查错误。</p>
<p>像java语言，就是结合了两者的处理。一个java程序先被编译为字节码，再由虚拟机逐个执行。</p>
<h3 id="编译执行流程"><a href="#编译执行流程" class="headerlink" title="编译执行流程"></a>编译执行流程</h3><p>词法分析：读入组成源程序的的字符流，例如temp &#x3D; b +c,我们会将temp映射成词法单词&lt;id,1&gt;，b和c同样这么干,变换后如下：</p>
<p>&lt;id,1&gt; &lt;&#x3D;&gt;&lt;id,2&gt; &lt;+&gt; &lt;id,3&gt; </p>
<p>语法分析：通过创建树形结构（语法树）表示语句，使用递归下降等方式进行解析</p>
<p>语义分析：符号表、类型检查都发生在这一步，会附加对应的语义动作。</p>
<p>中间代码生成：构造中间形式，例如三地址代码</p>
<p>以上就是前端内容了。</p>
<p>机器无关优化：主要通过数据流分析消除冗余。</p>
<p>寄存器分配：将变量分配到机器的物理寄存器中，以减少对内存的访问</p>
<p>机器相关优化：这是考虑具体架构做出的优化，像《Computer Architecture》中就介绍了很多这种技术，笔者印象比较深刻的就是寄存器重命名和机器周期优化了，主要是流水线化算法</p>
<p>代码生成：最终生成目标机器代码或汇编代码，并写入目标文件</p>
<p>编译器的设计思想从整体来看，就是函数式的思想，笔者猜测可能是与编译理论直接源于可计算理论有关，同时，编译器领域是最接近计算机原理的领域，像正则表达式和自动机这些东西，很难想象它们的发源居然来自神经网络理论。</p>
<p>以上就是编译执行流程了,现在让我们来看看C4的代码。</p>
<h2 id="C4源码"><a href="#C4源码" class="headerlink" title="C4源码"></a>C4源码</h2><h3 id="MAIN"><a href="#MAIN" class="headerlink" title="MAIN"></a>MAIN</h3><p>C4只用了四个函数： next( )，  expr( )， stmt( )， main( )</p>
<p>next( ):  词法分析器，解析标识符（由字母、数字和下划线组成），解析数字等并转化为标记。</p>
<p>expr( ):  语法分析器中解析表达式的部分，根据不同的文法，解析并生成表达式的中间代码。主要是运算符的解析为主，例如解引用，+，-，&#x2F;，*，在这一步，被解析的程序将会被构造为中间形式，C4的中间形式是虚拟机可识别的指令。</p>
<p>stmt( )：解析和执行不同类型的语句，例如if、while等语句。</p>
<p>main( ):  C4的编码风格比较简陋，排版不是非常美观，main函数不仅完成分配符号表、文本区、数据区和栈区的内存，虚拟机也被放在了main函数中，语法分析的一部分也被放在了main函数，对每个声明，确定基本类型、处理指针、检测重复定义，并添加到符号表，最后运行虚拟机。</p>
<p>框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Aa(词法分析器next)--&gt;Ab(表达式解析expr)--&gt;Ac(语句解析stmt)--&gt;Ad(中间代码)--&gt;Ae(虚拟机执行)</span><br><span class="line">Ba(main函数)--&gt;Bs(开辟内存空间段)--&gt;Bb(解析声明)--&gt;Bc(词法分析)--&gt;Bd(语法分析)--&gt;Be(虚拟机执行)</span><br></pre></td></tr></table></figure>





<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>各个词法单元：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// tokens and classes (operators last and in precedence order)</span><br><span class="line">enum &#123;</span><br><span class="line">  Num = 128, Fun, Sys, Glo, Loc, Id,</span><br><span class="line">  Char, Else, Enum, If, Int, Return, Sizeof, While,</span><br><span class="line">  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak</span><br><span class="line">&#125;;                                                                                                         </span><br></pre></td></tr></table></figure>

<p>词法分析器的返回是tk，它是一个全局变量，那么也很容易想象语法分析器的构造过程了，先判断tk的值，获取类型后生成对应中间形式。</p>
<p>词法分析器入口如下，第一个解析的标识符是”\n”，while(le &lt; e)是判断文本指针位置打印，之后是解析’#’,当然，由于C4不支持宏定义，因此也跳过，当获取词素与支持的类型没有匹配时，词法分析器会跳过，例如空格符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void next()</span><br><span class="line">&#123;</span><br><span class="line">  char *pp;</span><br><span class="line"></span><br><span class="line">  while (tk = *p) &#123;</span><br><span class="line">    ++p;</span><br><span class="line">    if (tk == &#x27;\n&#x27;) &#123;</span><br><span class="line">      if (src) &#123;</span><br><span class="line">        printf(&quot;%d: %.*s&quot;, line, p - lp, lp);</span><br><span class="line">        lp = p;</span><br><span class="line">        while (le &lt; e) &#123;</span><br><span class="line">          printf(&quot;%8.4s&quot;, &amp;&quot;LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,&quot;</span><br><span class="line">                           &quot;OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,&quot;</span><br><span class="line">                           &quot;OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,&quot;[*++le * 5]);</span><br><span class="line">          if (*le &lt;= ADJ) printf(&quot; %d\n&quot;, *++le); else printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++line;</span><br><span class="line">    &#125;</span><br><span class="line">     else if (tk == &#x27;#&#x27;) &#123;</span><br><span class="line">      while (*p != 0 &amp;&amp; *p != &#x27;\n&#x27;) ++p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当词法分析器运行到这里，意味着能够与标识符匹配的词素出现了，于是计算并保存哈希值，然后把数组地址往后偏移一个单独符号表的大小，这样就可以继续存储新的词素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">else if ((tk &gt;= &#x27;a&#x27; &amp;&amp; tk &lt;= &#x27;z&#x27;) || (tk &gt;= &#x27;A&#x27; &amp;&amp; tk &lt;= &#x27;Z&#x27;) || tk == &#x27;_&#x27;) &#123;</span><br><span class="line">     pp = p - 1;</span><br><span class="line">     while ((*p &gt;= &#x27;a&#x27; &amp;&amp; *p &lt;= &#x27;z&#x27;) || (*p &gt;= &#x27;A&#x27; &amp;&amp; *p &lt;= &#x27;Z&#x27;) || (*p &gt;= &#x27;0&#x27; &amp;&amp; *p &lt;= &#x27;9&#x27;) || *p == &#x27;_&#x27;)</span><br><span class="line">       tk = tk * 147 + *p++;</span><br><span class="line">     tk = (tk &lt;&lt; 6) + (p - pp);</span><br><span class="line">     id = sym;</span><br><span class="line">     while (id[Tk]) &#123;</span><br><span class="line">       if (tk == id[Hash] &amp;&amp; !memcmp((char *)id[Name], pp, p - pp)) &#123; tk = id[Tk]; return; &#125;</span><br><span class="line">       id = id + Idsz;</span><br><span class="line">     &#125;</span><br><span class="line">     id[Name] = (int)pp;</span><br><span class="line">     id[Hash] = tk;</span><br><span class="line">     tk = id[Tk] = Id;</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>对这些数字、字符串和注释的解析如下，(tk &amp; 15)这种写法，其实就是%16，也就是解析十六进制，这种写法很常见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">else if (tk &gt;= &#x27;0&#x27; &amp;&amp; tk &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">     if (ival = tk - &#x27;0&#x27;) &#123; while (*p &gt;= &#x27;0&#x27; &amp;&amp; *p &lt;= &#x27;9&#x27;) ival = ival * 10 + *p++ - &#x27;0&#x27;; &#125;</span><br><span class="line">     else if (*p == &#x27;x&#x27; || *p == &#x27;X&#x27;) &#123;</span><br><span class="line">       while ((tk = *++p) &amp;&amp; ((tk &gt;= &#x27;0&#x27; &amp;&amp; tk &lt;= &#x27;9&#x27;) || (tk &gt;= &#x27;a&#x27; &amp;&amp; tk &lt;= &#x27;f&#x27;) || (tk &gt;= &#x27;A&#x27; &amp;&amp; tk &lt;= &#x27;F&#x27;)))</span><br><span class="line">         ival = ival * 16 + (tk &amp; 15) + (tk &gt;= &#x27;A&#x27; ? 9 : 0);</span><br><span class="line">     &#125;</span><br><span class="line">     else &#123; while (*p &gt;= &#x27;0&#x27; &amp;&amp; *p &lt;= &#x27;7&#x27;) ival = ival * 8 + *p++ - &#x27;0&#x27;; &#125;</span><br><span class="line">     tk = Num;</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line">   else if (tk == &#x27;/&#x27;) &#123;</span><br><span class="line">     if (*p == &#x27;/&#x27;) &#123;</span><br><span class="line">       ++p;</span><br><span class="line">       while (*p != 0 &amp;&amp; *p != &#x27;\n&#x27;) ++p;</span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">       tk = Div;</span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else if (tk == &#x27;\&#x27;&#x27; || tk == &#x27;&quot;&#x27;) &#123;</span><br><span class="line">     pp = data;</span><br><span class="line">     while (*p != 0 &amp;&amp; *p != tk) &#123;</span><br><span class="line">       if ((ival = *p++) == &#x27;\\&#x27;) &#123;</span><br><span class="line">         if ((ival = *p++) == &#x27;n&#x27;) ival = &#x27;\n&#x27;;</span><br><span class="line">       &#125;</span><br><span class="line">       if (tk == &#x27;&quot;&#x27;) *data++ = ival;</span><br><span class="line">     &#125;</span><br><span class="line">     ++p;</span><br><span class="line">     if (tk == &#x27;&quot;&#x27;) ival = (int)pp; else tk = Num;</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>解析单目运算符和标点符号·：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">else if (tk == &#x27;=&#x27;) &#123; if (*p == &#x27;=&#x27;) &#123; ++p; tk = Eq; &#125; else tk = Assign; return; &#125;</span><br><span class="line">   else if (tk == &#x27;+&#x27;) &#123; if (*p == &#x27;+&#x27;) &#123; ++p; tk = Inc; &#125; else tk = Add; return; &#125;</span><br><span class="line">   else if (tk == &#x27;-&#x27;) &#123; if (*p == &#x27;-&#x27;) &#123; ++p; tk = Dec; &#125; else tk = Sub; return; &#125;</span><br><span class="line">   else if (tk == &#x27;!&#x27;) &#123; if (*p == &#x27;=&#x27;) &#123; ++p; tk = Ne; &#125; return; &#125;</span><br><span class="line">   else if (tk == &#x27;&lt;&#x27;) &#123; if (*p == &#x27;=&#x27;) &#123; ++p; tk = Le; &#125; else if (*p == &#x27;&lt;&#x27;) &#123; ++p; tk = Shl; &#125; else tk = Lt; return; &#125;</span><br><span class="line">   else if (tk == &#x27;&gt;&#x27;) &#123; if (*p == &#x27;=&#x27;) &#123; ++p; tk = Ge; &#125; else if (*p == &#x27;&gt;&#x27;) &#123; ++p; tk = Shr; &#125; else tk = Gt; return; &#125;</span><br><span class="line">   else if (tk == &#x27;|&#x27;) &#123; if (*p == &#x27;|&#x27;) &#123; ++p; tk = Lor; &#125; else tk = Or; return; &#125;</span><br><span class="line">   else if (tk == &#x27;&amp;&#x27;) &#123; if (*p == &#x27;&amp;&#x27;) &#123; ++p; tk = Lan; &#125; else tk = And; return; &#125;</span><br><span class="line">   else if (tk == &#x27;^&#x27;) &#123; tk = Xor; return; &#125;</span><br><span class="line">   else if (tk == &#x27;%&#x27;) &#123; tk = Mod; return; &#125;</span><br><span class="line">   else if (tk == &#x27;*&#x27;) &#123; tk = Mul; return; &#125;</span><br><span class="line">   else if (tk == &#x27;[&#x27;) &#123; tk = Brak; return; &#125;</span><br><span class="line">   else if (tk == &#x27;?&#x27;) &#123; tk = Cond; return; &#125;</span><br><span class="line">   else if (tk == &#x27;~&#x27; || tk == &#x27;;&#x27; || tk == &#x27;&#123;&#x27; || tk == &#x27;&#125;&#x27; || tk == &#x27;(&#x27; || tk == &#x27;)&#x27; || tk == &#x27;]&#x27; || tk == &#x27;,&#x27; || tk == &#x27;:&#x27;) return;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>C4的语法分析分为声明（declaration）、表达式(expr)和语句(stmt)的解析。</p>
<p>常见的解析手段有通用、自顶向下和自底向上三种，C4采用的是自顶向下解析。</p>
<p>语法分析在C4中的框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Aa(源程序)--输入--&gt;Ab(词法分析)--词素--&gt;Ac(语法分析)--中间形式--&gt;Af(虚拟机)--&gt;At(执行)</span><br><span class="line">Ac--获取下一个词素--&gt;Ab</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一个重要的部分，那就是符号表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Aa(词法分析)--&gt;Ab(语法分析)</span><br><span class="line">Aa--&gt;Ba(符号表)</span><br><span class="line">Ab----&gt;Ba(符号表)</span><br></pre></td></tr></table></figure>





<h3 id="解析声明"><a href="#解析声明" class="headerlink" title="解析声明"></a>解析声明</h3><p>词法分析已经帮助我们捕捉到了词素的类型，现在该语法分析登场了，首先是解析全局声明，这些类型有：int、char、enum、函数</p>
<p>C4采用自顶向下解析，但是本身并不支持递归，所以不能使用递归下降进行解析。</p>
<p>自顶向下解析：</p>
<p>假设我们有文法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E-&gt;TE&#x27;</span><br><span class="line">E&#x27;-&gt;+ TE&#x27; | 空</span><br><span class="line">T-&gt;FT&#x27;</span><br></pre></td></tr></table></figure>

<p>自顶向下解析如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<p>其实就是树的遍历展开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A((A))</span><br><span class="line">B((B))</span><br><span class="line">C((C))</span><br><span class="line">D((D))</span><br><span class="line">E((E))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A(E)--&gt;B(T)</span><br><span class="line">A(E)--&gt;C(E&#x27;)</span><br><span class="line">B--&gt;D(F)</span><br><span class="line">B--&gt;E(T&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>推完左边再推右边就行了，就不多展示了。</p>
<h4 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h4><p>int和char的文法不需要过多讲述，重点讲一讲enum和函数的文法：</p>
<p>enum文法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;EnumDecl&gt; ::= &quot;enum&quot; &lt;EnumName&gt; &quot;&#123;&quot; &lt;EnumList&gt; &quot;&#125;&quot;</span><br><span class="line">&lt;EnumName&gt; ::= &quot;IDENTIFIER&quot;</span><br><span class="line">&lt;EnumList&gt; ::= &lt;EnumItem&gt; | &lt;EnumItem&gt; &quot;,&quot; &lt;EnumList&gt;</span><br><span class="line">&lt;EnumItem&gt; ::= &quot;IDENTIFIER&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把C4中的文法写成一行，这样看起来就简洁多了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum的文法：enum_decl ::= &#x27;enum&#x27; [identifier] &#x27;&#123;&#x27; identifier [&#x27;=&#x27; number] &#123;&#x27;,&#x27; identifier [&#x27;=&#x27; number] &#x27;&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>函数文法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;FuncDecl&gt; ::= &lt;ReturnType&gt; &lt;FuncName&gt; &quot;(&quot; &lt;ParamList&gt; &quot;)&quot; &quot;&#123;&quot; &lt;FuncBody&gt; &quot;&#125;&quot;</span><br><span class="line">&lt;ReturnType&gt; ::= &quot;void&quot; | &quot;int&quot; | &quot;char&quot; | &quot;IDENTIFIER&quot;</span><br><span class="line">&lt;FuncName&gt; ::= &quot;IDENTIFIER&quot;</span><br><span class="line">&lt;ParamList&gt; ::= &lt;Param&gt; | &lt;Param&gt; &quot;,&quot; &lt;ParamList&gt; | &quot;&quot;</span><br><span class="line">&lt;FuncBody&gt; ::= &lt;StatementList&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下就是C4中对应的文法解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// parse declarations</span><br><span class="line">line = 1;</span><br><span class="line">next();</span><br><span class="line">while (tk) &#123;</span><br><span class="line">  bt = INT; // basetype</span><br><span class="line">  if (tk == Int) next();</span><br><span class="line">  else if (tk == Char) &#123; next(); bt = CHAR; &#125;</span><br><span class="line">  else if (tk == Enum) &#123;//enum的解析开始</span><br><span class="line">    next();</span><br><span class="line">    if (tk != &#x27;&#123;&#x27;) next();</span><br><span class="line">    if (tk == &#x27;&#123;&#x27;) &#123;</span><br><span class="line">      next();</span><br><span class="line">      i = 0;</span><br><span class="line">      while (tk != &#x27;&#125;&#x27;) &#123;</span><br><span class="line">        if (tk != Id) &#123; printf(&quot;%d: bad enum identifier %d\n&quot;, line, tk); return -1; &#125;</span><br><span class="line">        next();</span><br><span class="line">        if (tk == Assign) &#123;</span><br><span class="line">          next();</span><br><span class="line">          if (tk != Num) &#123; printf(&quot;%d: bad enum initializer\n&quot;, line); return -1; &#125;</span><br><span class="line">          i = ival;</span><br><span class="line">          next();</span><br><span class="line">        &#125;</span><br><span class="line">        id[Class] = Num; id[Type] = INT; id[Val] = i++;</span><br><span class="line">        if (tk == &#x27;,&#x27;) next();</span><br><span class="line">      &#125;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while (tk != &#x27;;&#x27; &amp;&amp; tk != &#x27;&#125;&#x27;) &#123;</span><br><span class="line">    ty = bt;</span><br><span class="line">    while (tk == Mul) &#123; next(); ty = ty + PTR; &#125;</span><br><span class="line">    if (tk != Id) &#123; printf(&quot;%d: bad global declaration\n&quot;, line); return -1; &#125;</span><br><span class="line">    if (id[Class]) &#123; printf(&quot;%d: duplicate global definition\n&quot;, line); return -1; &#125;</span><br><span class="line">    next();</span><br><span class="line">    id[Type] = ty;</span><br><span class="line">    if (tk == &#x27;(&#x27;) &#123; // 函数解析从这里开始</span><br><span class="line">      id[Class] = Fun;</span><br><span class="line">      id[Val] = (int)(e + 1);</span><br><span class="line">      next(); i = 0;</span><br><span class="line">      while (tk != &#x27;)&#x27;) &#123;</span><br><span class="line">        ty = INT;</span><br><span class="line">        if (tk == Int) next();</span><br><span class="line">        else if (tk == Char) &#123; next(); ty = CHAR; &#125;</span><br><span class="line">        while (tk == Mul) &#123; next(); ty = ty + PTR; &#125;</span><br><span class="line">        if (tk != Id) &#123; printf(&quot;%d: bad parameter declaration\n&quot;, line); return -1; &#125;</span><br><span class="line">        if (id[Class] == Loc) &#123; printf(&quot;%d: duplicate parameter definition\n&quot;, line); return -1; &#125;</span><br><span class="line">        id[HClass] = id[Class]; id[Class] = Loc;</span><br><span class="line">        id[HType]  = id[Type];  id[Type] = ty;</span><br><span class="line">        id[HVal]   = id[Val];   id[Val] = i++;</span><br><span class="line">        next();</span><br><span class="line">        if (tk == &#x27;,&#x27;) next();</span><br><span class="line">      &#125;</span><br><span class="line">      next();</span><br><span class="line">      if (tk != &#x27;&#123;&#x27;) &#123; printf(&quot;%d: bad function definition\n&quot;, line); return -1; &#125;</span><br><span class="line">      loc = ++i;</span><br><span class="line">      next();</span><br><span class="line">      while (tk == Int || tk == Char) &#123;</span><br><span class="line">        bt = (tk == Int) ? INT : CHAR;</span><br><span class="line">        next();</span><br><span class="line">        while (tk != &#x27;;&#x27;) &#123;</span><br><span class="line">          ty = bt;</span><br><span class="line">          while (tk == Mul) &#123; next(); ty = ty + PTR; &#125;</span><br><span class="line">          if (tk != Id) &#123; printf(&quot;%d: bad local declaration\n&quot;, line); return -1; &#125;</span><br><span class="line">          if (id[Class] == Loc) &#123; printf(&quot;%d: duplicate local definition\n&quot;, line); return -1; &#125;</span><br><span class="line">          id[HClass] = id[Class]; id[Class] = Loc;</span><br><span class="line">          id[HType]  = id[Type];  id[Type] = ty;</span><br><span class="line">          id[HVal]   = id[Val];   id[Val] = ++i;</span><br><span class="line">          next();</span><br><span class="line">          if (tk == &#x27;,&#x27;) next();</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">      &#125;</span><br><span class="line">      *++e = ENT; *++e = i - loc;</span><br><span class="line">      while (tk != &#x27;&#125;&#x27;) stmt();</span><br><span class="line">      *++e = LEV;</span><br><span class="line">      id = sym; // unwind symbol table locals</span><br><span class="line">      while (id[Tk]) &#123;</span><br><span class="line">        if (id[Class] == Loc) &#123;</span><br><span class="line">          id[Class] = id[HClass];</span><br><span class="line">          id[Type] = id[HType];</span><br><span class="line">          id[Val] = id[HVal];</span><br><span class="line">        &#125;</span><br><span class="line">        id = id + Idsz;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      id[Class] = Glo;</span><br><span class="line">      id[Val] = (int)data;</span><br><span class="line">      data = data + sizeof(int);</span><br><span class="line">    &#125;</span><br><span class="line">    if (tk == &#x27;,&#x27;) next();</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>声明解析完，接下来就是解析表达式（expr）和语句（stmt），顺便一提，C4的声明解析是放在main函数中进行的，也就是说，C4的声明必须在文法解析之前，像在函数语句后面定义变量的行为，C4是不支持的。</p>
<h3 id="解析表达式"><a href="#解析表达式" class="headerlink" title="解析表达式"></a>解析表达式</h3><p>我们从词法分析那里得到了词素的类型，当判断它是表达式后，我们就可以开始解析了，把它转换为虚拟机可识别的指令流，表达式的解析就是一元运算符、二元运算符和三元与算法的解析，例如加减乘除、与或非这些，这些东西的文法就不详细将了，详细地把每种运算符的解析文法都表示出来有点难受，毕竟笔者的分析只是以框架为主。</p>
<p>从框架中我们可以得知，语法分析就是在往内存模型中输出，之后就是虚拟机了，所以解析结果重点是虚拟机指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void expr(int lev)</span><br><span class="line">&#123;</span><br><span class="line">  int t, *d;</span><br><span class="line"></span><br><span class="line">  if (!tk) &#123; printf(&quot;%d: unexpected eof in expression\n&quot;, line); exit(-1); &#125;</span><br><span class="line">  else if (tk == Num) &#123; *++e = IMM; *++e = ival; next(); ty = INT; &#125;</span><br><span class="line">  else if (tk == &#x27;&quot;&#x27;) &#123;</span><br><span class="line">    *++e = IMM; *++e = ival; next();</span><br><span class="line">    while (tk == &#x27;&quot;&#x27;) next();</span><br><span class="line">    data = (char *)((int)data + sizeof(int) &amp; -sizeof(int)); ty = PTR;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == Sizeof) &#123;</span><br><span class="line">    next(); if (tk == &#x27;(&#x27;) next(); else &#123; printf(&quot;%d: open paren expected in sizeof\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    ty = INT; if (tk == Int) next(); else if (tk == Char) &#123; next(); ty = CHAR; &#125;</span><br><span class="line">    while (tk == Mul) &#123; next(); ty = ty + PTR; &#125;</span><br><span class="line">    if (tk == &#x27;)&#x27;) next(); else &#123; printf(&quot;%d: close paren expected in sizeof\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    *++e = IMM; *++e = (ty == CHAR) ? sizeof(char) : sizeof(int);</span><br><span class="line">    ty = INT;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == Id) &#123;</span><br><span class="line">    d = id; next();</span><br><span class="line">    if (tk == &#x27;(&#x27;) &#123;</span><br><span class="line">      next();</span><br><span class="line">      t = 0;</span><br><span class="line">      while (tk != &#x27;)&#x27;) &#123; expr(Assign); *++e = PSH; ++t; if (tk == &#x27;,&#x27;) next(); &#125;</span><br><span class="line">      next();</span><br><span class="line">      if (d[Class] == Sys) *++e = d[Val];</span><br><span class="line">      else if (d[Class] == Fun) &#123; *++e = JSR; *++e = d[Val]; &#125;</span><br><span class="line">      else &#123; printf(&quot;%d: bad function call\n&quot;, line); exit(-1); &#125;</span><br><span class="line">      if (t) &#123; *++e = ADJ; *++e = t; &#125;</span><br><span class="line">      ty = d[Type];</span><br><span class="line">    &#125;</span><br><span class="line">    else if (d[Class] == Num) &#123; *++e = IMM; *++e = d[Val]; ty = INT; &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      if (d[Class] == Loc) &#123; *++e = LEA; *++e = loc - d[Val]; &#125;</span><br><span class="line">      else if (d[Class] == Glo) &#123; *++e = IMM; *++e = d[Val]; &#125;</span><br><span class="line">      else &#123; printf(&quot;%d: undefined variable\n&quot;, line); exit(-1); &#125;</span><br><span class="line">      *++e = ((ty = d[Type]) == CHAR) ? LC : LI;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == &#x27;(&#x27;) &#123;</span><br><span class="line">    next();</span><br><span class="line">    if (tk == Int || tk == Char) &#123;</span><br><span class="line">      t = (tk == Int) ? INT : CHAR; next();</span><br><span class="line">      while (tk == Mul) &#123; next(); t = t + PTR; &#125;</span><br><span class="line">      if (tk == &#x27;)&#x27;) next(); else &#123; printf(&quot;%d: bad cast\n&quot;, line); exit(-1); &#125;</span><br><span class="line">      expr(Inc);</span><br><span class="line">      ty = t;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      expr(Assign);</span><br><span class="line">      if (tk == &#x27;)&#x27;) next(); else &#123; printf(&quot;%d: close paren expected\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == Mul) &#123;</span><br><span class="line">    next(); expr(Inc);</span><br><span class="line">    if (ty &gt; INT) ty = ty - PTR; else &#123; printf(&quot;%d: bad dereference\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    *++e = (ty == CHAR) ? LC : LI;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == And) &#123;</span><br><span class="line">    next(); expr(Inc);</span><br><span class="line">    if (*e == LC || *e == LI) --e; else &#123; printf(&quot;%d: bad address-of\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    ty = ty + PTR;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == &#x27;!&#x27;) &#123; next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = 0; *++e = EQ; ty = INT; &#125;</span><br><span class="line">  else if (tk == &#x27;~&#x27;) &#123; next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = -1; *++e = XOR; ty = INT; &#125;</span><br><span class="line">  else if (tk == Add) &#123; next(); expr(Inc); ty = INT; &#125;</span><br><span class="line">  else if (tk == Sub) &#123;</span><br><span class="line">    next(); *++e = IMM;</span><br><span class="line">    if (tk == Num) &#123; *++e = -ival; next(); &#125; else &#123; *++e = -1; *++e = PSH; expr(Inc); *++e = MUL; &#125;</span><br><span class="line">    ty = INT;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == Inc || tk == Dec) &#123;</span><br><span class="line">    t = tk; next(); expr(Inc);</span><br><span class="line">    if (*e == LC) &#123; *e = PSH; *++e = LC; &#125;</span><br><span class="line">    else if (*e == LI) &#123; *e = PSH; *++e = LI; &#125;</span><br><span class="line">    else &#123; printf(&quot;%d: bad lvalue in pre-increment\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    *++e = PSH;</span><br><span class="line">    *++e = IMM; *++e = (ty &gt; PTR) ? sizeof(int) : sizeof(char);</span><br><span class="line">    *++e = (t == Inc) ? ADD : SUB;</span><br><span class="line">    *++e = (ty == CHAR) ? SC : SI;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123; printf(&quot;%d: bad expression\n&quot;, line); exit(-1); &#125;</span><br><span class="line"></span><br><span class="line">  while (tk &gt;= lev) &#123; // &quot;precedence climbing&quot; or &quot;Top Down Operator Precedence&quot; method</span><br><span class="line">    t = ty;</span><br><span class="line">    if (tk == Assign) &#123;</span><br><span class="line">      next();</span><br><span class="line">      if (*e == LC || *e == LI) *e = PSH; else &#123; printf(&quot;%d: bad lvalue in assignment\n&quot;, line); exit(-1); &#125;</span><br><span class="line">      expr(Assign); *++e = ((ty = t) == CHAR) ? SC : SI;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (tk == Cond) &#123;</span><br><span class="line">      next();</span><br><span class="line">      *++e = BZ; d = ++e;</span><br><span class="line">      expr(Assign);</span><br><span class="line">      if (tk == &#x27;:&#x27;) next(); else &#123; printf(&quot;%d: conditional missing colon\n&quot;, line); exit(-1); &#125;</span><br><span class="line">      *d = (int)(e + 3); *++e = JMP; d = ++e;</span><br><span class="line">      expr(Cond);</span><br><span class="line">      *d = (int)(e + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (tk == Lor) &#123; next(); *++e = BNZ; d = ++e; expr(Lan); *d = (int)(e + 1); ty = INT; &#125;</span><br><span class="line">    else if (tk == Lan) &#123; next(); *++e = BZ;  d = ++e; expr(Or);  *d = (int)(e + 1); ty = INT; &#125;</span><br><span class="line">    else if (tk == Or)  &#123; next(); *++e = PSH; expr(Xor); *++e = OR;  ty = INT; &#125;</span><br><span class="line">    else if (tk == Xor) &#123; next(); *++e = PSH; expr(And); *++e = XOR; ty = INT; &#125;</span><br><span class="line">    else if (tk == And) &#123; next(); *++e = PSH; expr(Eq);  *++e = AND; ty = INT; &#125;</span><br><span class="line">    else if (tk == Eq)  &#123; next(); *++e = PSH; expr(Lt);  *++e = EQ;  ty = INT; &#125;</span><br><span class="line">    else if (tk == Ne)  &#123; next(); *++e = PSH; expr(Lt);  *++e = NE;  ty = INT; &#125;</span><br><span class="line">    else if (tk == Lt)  &#123; next(); *++e = PSH; expr(Shl); *++e = LT;  ty = INT; &#125;</span><br><span class="line">    else if (tk == Gt)  &#123; next(); *++e = PSH; expr(Shl); *++e = GT;  ty = INT; &#125;</span><br><span class="line">    else if (tk == Le)  &#123; next(); *++e = PSH; expr(Shl); *++e = LE;  ty = INT; &#125;</span><br><span class="line">    else if (tk == Ge)  &#123; next(); *++e = PSH; expr(Shl); *++e = GE;  ty = INT; &#125;</span><br><span class="line">    else if (tk == Shl) &#123; next(); *++e = PSH; expr(Add); *++e = SHL; ty = INT; &#125;</span><br><span class="line">    else if (tk == Shr) &#123; next(); *++e = PSH; expr(Add); *++e = SHR; ty = INT; &#125;</span><br><span class="line">    else if (tk == Add) &#123;</span><br><span class="line">      next(); *++e = PSH; expr(Mul);</span><br><span class="line">      if ((ty = t) &gt; PTR) &#123; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL;  &#125;</span><br><span class="line">      *++e = ADD;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (tk == Sub) &#123;</span><br><span class="line">      next(); *++e = PSH; expr(Mul);</span><br><span class="line">      if (t &gt; PTR &amp;&amp; t == ty) &#123; *++e = SUB; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = DIV; ty = INT; &#125;</span><br><span class="line">      else if ((ty = t) &gt; PTR) &#123; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL; *++e = SUB; &#125;</span><br><span class="line">      else *++e = SUB;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (tk == Mul) &#123; next(); *++e = PSH; expr(Inc); *++e = MUL; ty = INT; &#125;</span><br><span class="line">    else if (tk == Div) &#123; next(); *++e = PSH; expr(Inc); *++e = DIV; ty = INT; &#125;</span><br><span class="line">    else if (tk == Mod) &#123; next(); *++e = PSH; expr(Inc); *++e = MOD; ty = INT; &#125;</span><br><span class="line">    else if (tk == Inc || tk == Dec) &#123;</span><br><span class="line">      if (*e == LC) &#123; *e = PSH; *++e = LC; &#125;</span><br><span class="line">      else if (*e == LI) &#123; *e = PSH; *++e = LI; &#125;</span><br><span class="line">      else &#123; printf(&quot;%d: bad lvalue in post-increment\n&quot;, line); exit(-1); &#125;</span><br><span class="line">      *++e = PSH; *++e = IMM; *++e = (ty &gt; PTR) ? sizeof(int) : sizeof(char);</span><br><span class="line">      *++e = (tk == Inc) ? ADD : SUB;</span><br><span class="line">      *++e = (ty == CHAR) ? SC : SI;</span><br><span class="line">      *++e = PSH; *++e = IMM; *++e = (ty &gt; PTR) ? sizeof(int) : sizeof(char);</span><br><span class="line">      *++e = (tk == Inc) ? SUB : ADD;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (tk == Brak) &#123;</span><br><span class="line">      next(); *++e = PSH; expr(Assign);</span><br><span class="line">      if (tk == &#x27;]&#x27;) next(); else &#123; printf(&quot;%d: close bracket expected\n&quot;, line); exit(-1); &#125;</span><br><span class="line">      if (t &gt; PTR) &#123; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL;  &#125;</span><br><span class="line">      else if (t &lt; PTR) &#123; printf(&quot;%d: pointer type expected\n&quot;, line); exit(-1); &#125;</span><br><span class="line">      *++e = ADD;</span><br><span class="line">      *++e = ((ty = t - PTR) == CHAR) ? LC : LI;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; printf(&quot;%d: compiler error tk=%d\n&quot;, line, tk); exit(-1); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="解析语句"><a href="#解析语句" class="headerlink" title="解析语句"></a>解析语句</h3><p>C4解析的语句，包括 if 语句、while 语句、return 语句、块语句和表达式语句。</p>
<p>解析文法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;stmt&gt; ::= &#x27;if&#x27; &#x27;(&#x27; &lt;expr&gt; &#x27;)&#x27; &lt;stmt&gt; [&#x27;else&#x27; &lt;stmt&gt;]</span><br><span class="line">         | &#x27;while&#x27; &#x27;(&#x27; &lt;expr&gt; &#x27;)&#x27; &lt;stmt&gt;</span><br><span class="line">         | &#x27;return&#x27; [&lt;expr&gt;] &#x27;;&#x27;</span><br><span class="line">         | &#x27;&#123;&#x27; &#123;&lt;stmt&gt;&#125; &#x27;&#125;&#x27;</span><br><span class="line">         | &#x27;;&#x27;</span><br><span class="line">         | &lt;expr&gt; &#x27;;&#x27;</span><br><span class="line"></span><br><span class="line">&lt;expr&gt; ::= &lt;identifier&gt; &#x27;=&#x27; &lt;expr&gt;</span><br><span class="line">         | &lt;identifier&gt; &#x27;+&#x27; &lt;expr&gt;</span><br><span class="line">         | &lt;identifier&gt; &#x27;-&#x27; &lt;expr&gt;</span><br><span class="line">         | &lt;identifier&gt; &#x27;*&#x27; &lt;expr&gt;</span><br><span class="line">         | &lt;identifier&gt; &#x27;/&#x27; &lt;expr&gt;</span><br><span class="line">         | &lt;identifier&gt;</span><br><span class="line">         | &lt;number&gt;</span><br><span class="line"></span><br><span class="line">&lt;identifier&gt; ::= [A-Za-z_][A-Za-z0-9_]*</span><br><span class="line">&lt;number&gt; ::= [0-9]+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void stmt()</span><br><span class="line">&#123;</span><br><span class="line">  int *a, *b;</span><br><span class="line"></span><br><span class="line">  if (tk == If) &#123;</span><br><span class="line">    next();</span><br><span class="line">    if (tk == &#x27;(&#x27;) next(); else &#123; printf(&quot;%d: open paren expected\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    expr(Assign);</span><br><span class="line">    if (tk == &#x27;)&#x27;) next(); else &#123; printf(&quot;%d: close paren expected\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    *++e = BZ; b = ++e;</span><br><span class="line">    stmt();</span><br><span class="line">    if (tk == Else) &#123;</span><br><span class="line">      *b = (int)(e + 3); *++e = JMP; b = ++e;</span><br><span class="line">      next();</span><br><span class="line">      stmt();</span><br><span class="line">    &#125;</span><br><span class="line">    *b = (int)(e + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == While) &#123;</span><br><span class="line">    next();</span><br><span class="line">    a = e + 1;</span><br><span class="line">    if (tk == &#x27;(&#x27;) next(); else &#123; printf(&quot;%d: open paren expected\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    expr(Assign);</span><br><span class="line">    if (tk == &#x27;)&#x27;) next(); else &#123; printf(&quot;%d: close paren expected\n&quot;, line); exit(-1); &#125;</span><br><span class="line">    *++e = BZ; b = ++e;</span><br><span class="line">    stmt();</span><br><span class="line">    *++e = JMP; *++e = (int)a;</span><br><span class="line">    *b = (int)(e + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == Return) &#123;</span><br><span class="line">    next();</span><br><span class="line">    if (tk != &#x27;;&#x27;) expr(Assign);</span><br><span class="line">    *++e = LEV;</span><br><span class="line">    if (tk == &#x27;;&#x27;) next(); else &#123; printf(&quot;%d: semicolon expected\n&quot;, line); exit(-1); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == &#x27;&#123;&#x27;) &#123;</span><br><span class="line">    next();</span><br><span class="line">    while (tk != &#x27;&#125;&#x27;) stmt();</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">  else if (tk == &#x27;;&#x27;) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    expr(Assign);</span><br><span class="line">    if (tk == &#x27;;&#x27;) next(); else &#123; printf(&quot;%d: semicolon expected\n&quot;, line); exit(-1); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机是C4运行的核心， “程序的80%的运行时间花在20%的代码上”，理解了虚拟机，就理解了C4的框架。</p>
<p>现在让我们先看看虚拟机的实现，从虚拟机中我们可以看见C4工作原理，不过再此之前笔者要讲一讲内存模型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Aa(词法分析)--&gt;Ab(语法分析)--&gt;Ac(输出到内存模型)--&gt;Ad(虚拟机根据内存信息执行)--&gt;Ae(输出结果)</span><br></pre></td></tr></table></figure>





<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>c常见的elf文件模型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">|       栈段 (Stack)     |</span><br><span class="line">| (局部变量、函数调用帧)  |</span><br><span class="line">+-----------------------+</span><br><span class="line">|       堆段 (Heap)      |</span><br><span class="line">| (动态分配的内存)       |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 未初始化数据段 (BSS)   |</span><br><span class="line">| (未初始化的全局和静态变量)|</span><br><span class="line">+-----------------------+</span><br><span class="line">| 已初始化数据段 (Data)  |</span><br><span class="line">| (已初始化的全局和静态变量)|</span><br><span class="line">+-----------------------+</span><br><span class="line">|       只读数据段      |</span><br><span class="line">|   (常量字符串、只读变量)|</span><br><span class="line">+-----------------------+</span><br><span class="line">|       代码段 (Text)   |</span><br><span class="line">| (程序指令、常量等)     |</span><br><span class="line">+-----------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这是编译器编译后的文件，可以看出不同的内存段存储不同信息。</p>
<p>同理，C4也实现了类似的内存模型,让我们看看main函数：</p>
<p>C4的内存模型并不是严格的elf文件格式，只有text段、数据段、栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  int fd, bt, ty, poolsz, *idmain;</span><br><span class="line">  int *pc, *sp, *bp, a, cycle; // vm registers</span><br><span class="line">  int i, *t; // temps</span><br><span class="line"></span><br><span class="line">  --argc; ++argv;</span><br><span class="line">  if (argc &gt; 0 &amp;&amp; **argv == &#x27;-&#x27; &amp;&amp; (*argv)[1] == &#x27;s&#x27;) &#123; src = 1; --argc; ++argv; &#125;</span><br><span class="line">  if (argc &gt; 0 &amp;&amp; **argv == &#x27;-&#x27; &amp;&amp; (*argv)[1] == &#x27;d&#x27;) &#123; debug = 1; --argc; ++argv; &#125;</span><br><span class="line">  if (argc &lt; 1) &#123; printf(&quot;usage: c4 [-s] [-d] file ...\n&quot;); return -1; &#125;</span><br><span class="line"></span><br><span class="line">  if ((fd = open(*argv, 0)) &lt; 0) &#123; printf(&quot;could not open(%s)\n&quot;, *argv); return -1; &#125;</span><br><span class="line"></span><br><span class="line">  poolsz = 256*1024; // arbitrary size</span><br><span class="line">  if (!(sym = malloc(poolsz))) &#123; printf(&quot;could not malloc(%d) symbol area\n&quot;, poolsz); return -1; &#125;</span><br><span class="line">  if (!(le = e = malloc(poolsz))) &#123; printf(&quot;could not malloc(%d) text area\n&quot;, poolsz); return -1; &#125;</span><br><span class="line">  if (!(data = malloc(poolsz))) &#123; printf(&quot;could not malloc(%d) data area\n&quot;, poolsz); return -1; &#125;</span><br><span class="line">  if (!(sp = malloc(poolsz))) &#123; printf(&quot;could not malloc(%d) stack area\n&quot;, poolsz); return -1; &#125;</span><br><span class="line"></span><br><span class="line">  memset(sym,  0, poolsz);</span><br><span class="line">  memset(e,    0, poolsz);</span><br><span class="line">  memset(data, 0, poolsz);</span><br><span class="line"></span><br><span class="line">  p = &quot;char else enum if int return sizeof while &quot;</span><br><span class="line">      &quot;open read close printf malloc free memset memcmp exit void main&quot;;</span><br><span class="line">  i = Char; while (i &lt;= While) &#123; next(); id[Tk] = i++; &#125; // add keywords to symbol table</span><br><span class="line">  i = OPEN; while (i &lt;= EXIT) &#123; next(); id[Class] = Sys; id[Type] = INT; id[Val] = i++; &#125; // add library to symbol table</span><br><span class="line">  next(); id[Tk] = Char; // handle void type</span><br><span class="line">  next(); idmain = id; // keep track of main</span><br><span class="line"></span><br><span class="line">  if (!(lp = p = malloc(poolsz))) &#123; printf(&quot;could not malloc(%d) source area\n&quot;, poolsz); return -1; &#125;</span><br><span class="line">  if ((i = read(fd, p, poolsz-1)) &lt;= 0) &#123; printf(&quot;read() returned %d\n&quot;, i); return -1; &#125;</span><br><span class="line">  p[i] = 0;</span><br><span class="line">  close(fd);</span><br></pre></td></tr></table></figure>



<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><p>虚拟机会从text段开始，一个个指令读，然后实现对应的操作，</p>
<p>C4的虚拟机实现具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// setup stack</span><br><span class="line">  bp = sp = (int *)((int)sp + poolsz);</span><br><span class="line">  *--sp = EXIT; // call exit if main returns</span><br><span class="line">  *--sp = PSH; t = sp;</span><br><span class="line">  *--sp = argc;</span><br><span class="line">  *--sp = (int)argv;</span><br><span class="line">  *--sp = (int)t;</span><br><span class="line"></span><br><span class="line">  // run...</span><br><span class="line">  cycle = 0;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    i = *pc++; ++cycle;</span><br><span class="line">    if (debug) &#123;</span><br><span class="line">      printf(&quot;%d&gt; %.4s&quot;, cycle,</span><br><span class="line">        &amp;&quot;LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,&quot;</span><br><span class="line">         &quot;OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,&quot;</span><br><span class="line">         &quot;OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,&quot;[i * 5]);</span><br><span class="line">      if (i &lt;= ADJ) printf(&quot; %d\n&quot;, *pc); else printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if      (i == LEA) a = (int)(bp + *pc++);                             // load local address</span><br><span class="line">    else if (i == IMM) a = *pc++;                                         // load global address or immediate</span><br><span class="line">    else if (i == JMP) pc = (int *)*pc;                                   // jump</span><br><span class="line">    else if (i == JSR) &#123; *--sp = (int)(pc + 1); pc = (int *)*pc; &#125;        // jump to subroutine</span><br><span class="line">    else if (i == BZ)  pc = a ? pc + 1 : (int *)*pc;                      // branch if zero</span><br><span class="line">    else if (i == BNZ) pc = a ? (int *)*pc : pc + 1;                      // branch if not zero</span><br><span class="line">    else if (i == ENT) &#123; *--sp = (int)bp; bp = sp; sp = sp - *pc++; &#125;     // enter subroutine</span><br><span class="line">    else if (i == ADJ) sp = sp + *pc++;                                   // stack adjust</span><br><span class="line">    else if (i == LEV) &#123; sp = bp; bp = (int *)*sp++; pc = (int *)*sp++; &#125; // leave subroutine</span><br><span class="line">    else if (i == LI)  a = *(int *)a;                                     // load int</span><br><span class="line">    else if (i == LC)  a = *(char *)a;                                    // load char</span><br><span class="line">    else if (i == SI)  *(int *)*sp++ = a;                                 // store int</span><br><span class="line">    else if (i == SC)  a = *(char *)*sp++ = a;                            // store char</span><br><span class="line">    else if (i == PSH) *--sp = a;                                         // push</span><br><span class="line"></span><br><span class="line">    else if (i == OR)  a = *sp++ |  a;</span><br><span class="line">    else if (i == XOR) a = *sp++ ^  a;</span><br><span class="line">    else if (i == AND) a = *sp++ &amp;  a;</span><br><span class="line">    else if (i == EQ)  a = *sp++ == a;</span><br><span class="line">    else if (i == NE)  a = *sp++ != a;</span><br><span class="line">    else if (i == LT)  a = *sp++ &lt;  a;</span><br><span class="line">    else if (i == GT)  a = *sp++ &gt;  a;</span><br><span class="line">    else if (i == LE)  a = *sp++ &lt;= a;</span><br><span class="line">    else if (i == GE)  a = *sp++ &gt;= a;</span><br><span class="line">    else if (i == SHL) a = *sp++ &lt;&lt; a;</span><br><span class="line">    else if (i == SHR) a = *sp++ &gt;&gt; a;</span><br><span class="line">    else if (i == ADD) a = *sp++ +  a;</span><br><span class="line">    else if (i == SUB) a = *sp++ -  a;</span><br><span class="line">    else if (i == MUL) a = *sp++ *  a;</span><br><span class="line">    else if (i == DIV) a = *sp++ /  a;</span><br><span class="line">    else if (i == MOD) a = *sp++ %  a;</span><br><span class="line"></span><br><span class="line">    else if (i == OPEN) a = open((char *)sp[1], *sp);</span><br><span class="line">    else if (i == READ) a = read(sp[2], (char *)sp[1], *sp);</span><br><span class="line">    else if (i == CLOS) a = close(*sp);</span><br><span class="line">    else if (i == PRTF) &#123; t = sp + pc[1]; a = printf((char *)t[-1], t[-2], t[-3], t[-4], t[-5], t[-6]); &#125;</span><br><span class="line">    else if (i == MALC) a = (int)malloc(*sp);</span><br><span class="line">    else if (i == FREE) free((void *)*sp);</span><br><span class="line">    else if (i == MSET) a = (int)memset((char *)sp[2], sp[1], *sp);</span><br><span class="line">    else if (i == MCMP) a = memcmp((char *)sp[2], (char *)sp[1], *sp);</span><br><span class="line">    else if (i == EXIT) &#123; printf(&quot;exit(%d) cycle = %d\n&quot;, *sp, cycle); return *sp; &#125;</span><br><span class="line">    else &#123; printf(&quot;unknown instruction = %d! cycle = %d\n&quot;, i, cycle); return -1; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>举个例子，我们要计算1+1，要怎么写指令呢？虚拟机会怎么执行呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int text[1000];</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    text[i++] = IMM;   text[i++] = 1;    </span><br><span class="line">    text[i++] = PSH;                     </span><br><span class="line">    text[i++] = IMM;   text[i++] = 1;     </span><br><span class="line">    text[i++] = PSH;                     </span><br><span class="line">    text[i++] = ADD;                    </span><br><span class="line">    text[i++] = SI;    text[i++] = 0;     </span><br><span class="line">    text[i++] = LI;    text[i++] = 0;    </span><br><span class="line">    text[i++] = PRTF;  text[i++] = 0;    </span><br><span class="line">    text[i++] = EXIT;                    </span><br><span class="line"></span><br><span class="line">    后面是虚拟机的代码：</span><br><span class="line">     // run...</span><br><span class="line">  cycle = 0;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">   虚拟机代码太长，懒得复制粘贴了。</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上所示，虚拟机执行步骤如下：</p>
<p>加载立即数 1并压入栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text[i++] = IMM;   text[i++] = 1;     </span><br><span class="line">    text[i++] = PSH;                    </span><br></pre></td></tr></table></figure>

<p>再加载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text[i++] = IMM;   text[i++] = 1;    </span><br><span class="line">    text[i++] = PSH;                  </span><br></pre></td></tr></table></figure>

<p>栈顶两个数相加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text[i++] = ADD;                 </span><br></pre></td></tr></table></figure>

<p>将结果存储到位置 0:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text[i++] = SI;    text[i++] = 0;    </span><br></pre></td></tr></table></figure>

<p>从位置 0 加载值到栈顶:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text[i++] = LI;    text[i++] = 0;</span><br></pre></td></tr></table></figure>

<p>打印栈顶值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text[i++] = PRTF;  text[i++] = 0;</span><br></pre></td></tr></table></figure>

<p>退出程序:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text[i++] = EXIT;   </span><br></pre></td></tr></table></figure>



<h3 id="虚拟机的x86版本"><a href="#虚拟机的x86版本" class="headerlink" title="虚拟机的x86版本"></a>虚拟机的x86版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">while (pc &lt;= e) &#123;</span><br><span class="line">    i = *pc;</span><br><span class="line">    if (src) &#123;</span><br><span class="line">        while (line &lt; srcmap[pc - text]) &#123;</span><br><span class="line">            line++; printf(&quot;% 4d | %.*s&quot;, line, linemap[line + 1] - linemap[line], linemap[line]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;0x%05x (%p):\t%8.4s&quot;, pc - text, je,</span><br><span class="line">                        &amp;&quot;LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,&quot;</span><br><span class="line">                         &quot;OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,&quot;</span><br><span class="line">                         &quot;OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,MCPY,MMAP,DOPN,DSYM,QSRT,EXIT,&quot;[i * 5]);</span><br><span class="line">        if (i &lt;= ADJ) printf(&quot; 0x%x\n&quot;, *(pc + 1)); else printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    jitmap[pc - text] = je;  // for later relocation of JMP/JSR/BZ/BNZ</span><br><span class="line">    pc++;</span><br><span class="line">    if (i == LEA) &#123;</span><br><span class="line">      i = 4 * *pc++; if (i &lt; -128 || i &gt; 127) &#123; printf(&quot;jit: LEA out of bounds\n&quot;); return -1; &#125;</span><br><span class="line">      *(int*)je = 0x458d; je = je + 2; *je++ = i;  // leal $(4 * n)(%ebp), %eax</span><br><span class="line">    &#125;</span><br><span class="line">    else if (i == ENT) &#123;</span><br><span class="line">      i = 4 * *pc++; if (i &lt; -128 || i &gt; 127) &#123; printf(&quot;jit: ENT out of bounds\n&quot;); return -1; &#125;</span><br><span class="line">      *(int *)je = 0xe58955; je = je + 3;  // push %ebp; movl %esp, %ebp</span><br><span class="line">      if (i &gt; 0) &#123; *(int *)je = 0xec83; je = je + 2; *(int*)je++ = i; &#125; // subl $(i*4), %esp</span><br><span class="line">    &#125;</span><br><span class="line">    else if (i == IMM) &#123; *je++ = 0xb8; *(int *)je = *pc++; je = je + 4; &#125; // movl $imm, %eax</span><br><span class="line">    else if (i == ADJ) &#123; i = 4 * *pc++; *(int *)je = 0xc483; je = je + 2; *(int *)je = i; je++; &#125; // addl $(n * 4), %esp</span><br><span class="line">    else if (i == PSH)   *(int *)je++ = 0x50;                    // push %eax</span><br><span class="line">    else if (i == LEV) &#123; *(int *)je = 0xc35dec89; je = je + 4; &#125; // mov %ebp, %esp; pop %ebp; ret</span><br><span class="line">    else if (i == LI)  &#123; *(int *)je = 0x008b;     je = je + 2; &#125; // movl (%eax), %eax</span><br><span class="line">    else if (i == LC)  &#123; *(int *)je = 0x00b60f;   je = je + 3; &#125; // movzbl (%eax), %eax</span><br><span class="line">    else if (i == SI)  &#123; *(int *)je = 0x018959;   je = je + 3; &#125; // pop %ecx; movl %eax, (%ecx)</span><br><span class="line">    else if (i == SC)  &#123; *(int *)je = 0x018859;   je = je + 3; &#125; // pop %ecx; movb %al, (%ecx)</span><br><span class="line">    else if (i == OR)  &#123; *(int *)je = 0xc80959;   je = je + 3; &#125; // pop %ecx; orl %ecx, %eax</span><br><span class="line">    else if (i == XOR) &#123; *(int *)je = 0xc83159;   je = je + 3; &#125; // pop %ecx; xorl %ecx, %eax</span><br><span class="line">    else if (i == AND) &#123; *(int *)je = 0xc82159;   je = je + 3; &#125; // pop %ecx; andl %ecx, %eax</span><br><span class="line">    else if (EQ &lt;= i &amp;&amp; i &lt;= GE) &#123;</span><br><span class="line">        *(int*)je=0x0fc13959; je = je + 4; *(int*)je=0x9866c094; // pop %ecx; cmp %ecx, %eax; sete %al; cbw; - EQ</span><br><span class="line">        if      (i == NE)  &#123; *je = 0x95; &#125; // setne %al</span><br><span class="line">        else if (i == LT)  &#123; *je = 0x9c; &#125; // setl %al</span><br><span class="line">        else if (i == GT)  &#123; *je = 0x9f; &#125; // setg %al</span><br><span class="line">        else if (i == LE)  &#123; *je = 0x9e; &#125; // setle %al</span><br><span class="line">        else if (i == GE)  &#123; *je = 0x9d; &#125; // setge %al</span><br><span class="line">        je=je+4; *je++=0x98;  // cwde</span><br><span class="line">    &#125;</span><br><span class="line">    else if (i == SHL) &#123; *(int*)je = 0xe0d39159; je = je + 4; &#125; // pop %ecx; xchg %eax, %ecx; shl %cl, %eax</span><br><span class="line">    else if (i == SHR) &#123; *(int*)je = 0xe8d39159; je = je + 4; &#125; // pop %ecx; xchg %eax, %ecx; shr %cl, %eax</span><br><span class="line">    else if (i == ADD) &#123; *(int*)je = 0xc80159;   je = je + 3; &#125; // pop %ecx; addl %ecx, %eax</span><br><span class="line">    else if (i == SUB) &#123; *(int*)je = 0xc8299159; je = je + 4; &#125; // pop %ecx; xchg %eax, %ecx; subl %ecx, %eax</span><br><span class="line">    else if (i == MUL) &#123; *(int*)je = 0xc1af0f59; je = je + 4; &#125; // pop %ecx; imul %ecx, %eax</span><br><span class="line">    else if (i == DIV) &#123; *(int*)je = 0xf9f79159; je = je + 4; &#125; // pop %ecx; xchg %eax, %ecx; idiv %ecx, %eax</span><br><span class="line">    else if (i == MOD) &#123; *(int*)je = 0xd2319159; je = je + 4; *(int *)je = 0x92f9f7; je = je + 3; &#125;</span><br><span class="line">    else if (i == JMP) &#123; ++pc; *je       = 0xe9;     je = je + 5; &#125; // jmp &lt;off32&gt;</span><br><span class="line">    else if (i == JSR) &#123; ++pc; *je       = 0xe8;     je = je + 5; &#125; // call &lt;off32&gt;</span><br><span class="line">    else if (i == BZ)  &#123; ++pc; *(int*)je = 0x840fc085; je = je + 8; &#125; // test %eax, %eax; jz &lt;off32&gt;</span><br><span class="line">    else if (i == BNZ) &#123; ++pc; *(int*)je = 0x850fc085; je = je + 8; &#125; // test %eax, %eax; jnz &lt;off32&gt;</span><br><span class="line">    else if (i &gt;= OPEN) &#123;</span><br><span class="line">      if      (i == OPEN) tmp = (int)dlsym(dl, &quot;open&quot;);</span><br><span class="line">      else if (i == READ) tmp = (int)dlsym(dl, &quot;read&quot;);</span><br><span class="line">      else if (i == CLOS) tmp = (int)dlsym(dl, &quot;close&quot;);</span><br><span class="line">      else if (i == PRTF) tmp = (int)dlsym(dl, &quot;printf&quot;);</span><br><span class="line">      else if (i == MALC) tmp = (int)dlsym(dl, &quot;malloc&quot;);</span><br><span class="line">      else if (i == MSET) tmp = (int)dlsym(dl, &quot;memset&quot;);</span><br><span class="line">      else if (i == MCMP) tmp = (int)dlsym(dl, &quot;memcmp&quot;);</span><br><span class="line">      else if (i == MCPY) tmp = (int)dlsym(dl, &quot;memcpy&quot;);</span><br><span class="line">      else if (i == MMAP) tmp = (int)dlsym(dl, &quot;mmap&quot;);</span><br><span class="line">      else if (i == DOPN) tmp = (int)dlsym(dl, &quot;dlopen&quot;);</span><br><span class="line">      else if (i == DSYM) tmp = (int)dlsym(dl, &quot;dlsym&quot;);</span><br><span class="line">      else if (i == QSRT) tmp = (int)dlsym(dl, &quot;qsort&quot;);</span><br><span class="line">      else if (i == EXIT) tmp = (int)dlsym(dl, &quot;exit&quot;);</span><br><span class="line"></span><br><span class="line">      if (*pc++ == ADJ) &#123; i = *pc++; &#125; else &#123; printf(&quot;no ADJ after native proc!\n&quot;); exit(2); &#125;</span><br><span class="line"></span><br><span class="line">      *je++ = 0xb9; *(int*)je = i &lt;&lt; 2; je = je + 4;  // movl $(4 * n), %ecx;</span><br><span class="line">      *(int*)je = 0xce29e689; je = je + 4; // mov %esp, %esi; sub %ecx, %esi;  -- %esi will adjust the stack</span><br><span class="line">      *(int*)je = 0x8302e9c1; je = je + 4; // shr $2, %ecx; and                -- alignment of %esp for OS X</span><br><span class="line">      *(int*)je = 0x895af0e6; je = je + 4; // $0xfffffff0, %esi; pop %edx; mov..</span><br><span class="line">      *(int*)je = 0xe2fc8e54; je = je + 4; // ..%edx, -4(%esi,%ecx,4); loop..  -- reversing args order</span><br><span class="line">      *(int*)je = 0xe8f487f9; je = je + 4; // ..&lt;&#x27;pop&#x27; offset&gt;; xchg %esi, %esp; call    -- saving old stack in %esi</span><br><span class="line">      *(int*)je = tmp - (int)(je + 4); je = je + 4; // &lt;*tmp offset&gt;;</span><br><span class="line">      *(int*)je = 0xf487; je = je + 2;     // xchg %esi, %esp  -- ADJ, back to old stack without arguments</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; printf(&quot;code generation failed for %d!\n&quot;, i); return -1; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>赋值给je的十六进制是x86架构下的操作码，这样C4就能解析x86下的部分c语言文件了。</p>
<p>让我们再回头看一下C4框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Aa(词法分析)--&gt;Ab(语法分析)--&gt;Ac(输出到内存模型)--&gt;Ad(虚拟机根据内存信息执行)--&gt;Ae(输出结果)</span><br></pre></td></tr></table></figure>



<p>词法分析会捕捉每一个词法单元，也就是词素，然后它会返回对应的结果，语法分析根据返回的结果，可以确定是哪一个类型的词素并执行对应的操作，解析的结果会被放在内存模型中，当解析完后，内存模型也就完成了编译的写入，然后虚拟机开始干活了，它根据内存模型内的信息，从text段开始执行，text段全部都是指令，当然，肯定有读者好奇，怎么从数据段访问那些变量？这个不必担心，全局和静态变量在编译时已经分配了特定的内存地址。在程序执行时，虚拟机通过这些地址访问变量。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/compiler/" rel="tag">compiler</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/12/17/SparrowRTOS%E7%A7%BB%E6%A4%8D/">SparrowRTOS移植</a><a class="next" href="/2024/12/10/GdbPythonAPI/">GdbPythonAPI</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/compiler/" style="font-size: 15px;">compiler</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/RTOS/" style="font-size: 15px;">RTOS</a> <a href="/tags/TCP-IP-stack/" style="font-size: 15px;">TCP/IP stack</a> <a href="/tags/UDP/" style="font-size: 15px;">UDP</a> <a href="/tags/C-language/" style="font-size: 15px;">C language</a> <a href="/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/" style="font-size: 15px;">虚函数表</a> <a href="/tags/c-flow/" style="font-size: 15px;">c flow</a> <a href="/tags/linux-kernel/" style="font-size: 15px;">linux kernel</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 15px;">内存</a> <a href="/tags/Embedded-RTOS/" style="font-size: 15px;">Embedded RTOS</a> <a href="/tags/c-language/" style="font-size: 15px;">c language</a> <a href="/tags/C-lauguage/" style="font-size: 15px;">C lauguage</a> <a href="/tags/compilers/" style="font-size: 15px;">compilers</a> <a href="/tags/data-struct/" style="font-size: 15px;">data struct</a> <a href="/tags/ble/" style="font-size: 15px;">ble</a> <a href="/tags/IP/" style="font-size: 15px;">IP</a> <a href="/tags/cortex-A7/" style="font-size: 15px;">cortex A7</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a> <a href="/tags/tc/" style="font-size: 15px;">tc</a> <a href="/tags/early-demux/" style="font-size: 15px;">early demux</a> <a href="/tags/tags/" style="font-size: 15px;">tags</a> <a href="/tags/%E5%93%B2%E5%AD%A6/" style="font-size: 15px;">哲学</a> <a href="/tags/net/" style="font-size: 15px;">net</a> <a href="/tags/memory/" style="font-size: 15px;">memory</a> <a href="/tags/ARP/" style="font-size: 15px;">ARP</a> <a href="/tags/eBPF/" style="font-size: 15px;">eBPF</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/09/01/%E7%BD%91%E7%BB%9C%E4%B9%9D-Linux%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%86%85%E5%AD%98%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E6%8B%B7%E8%B4%9D/">网络九:Linux网络与内存应用层的拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/31/%E7%BD%91%E7%BB%9C%E5%85%AB%EF%BC%9ALinux%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%86%85%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E6%8B%B7%E8%B4%9D/">网络八：Linux网络与内存(数据包与拷贝)</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/30/%E7%BD%91%E7%BB%9C%E4%B8%83-Linux%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">网络七:Linux网络与内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/28/%E7%B2%BE%E7%A5%9E%E7%8E%B0%E8%B1%A1%E5%AD%A6%E4%B8%80/">精神现象学一</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/27/%E7%BD%91%E7%BB%9C%E5%85%AD-eBPF%E4%B8%8EARP%E6%AC%BA%E9%AA%97/">网络六:eBPF与ARP欺骗</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/27/%E7%BD%91%E7%BB%9C%E4%BA%94-%E5%AE%9E%E7%8E%B0ARP/">网络五:实现ARP</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/26/%E7%BD%91%E7%BB%9C%E5%9B%9B-%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%9E%B6%E6%9E%84/">网络四:协议栈与流水线架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/25/linux%E7%BD%91%E7%BB%9C%E4%B9%8Bdemux/">linux网络之demux</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/24/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AE%97%E6%B3%95/">内存管理算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/23/%E7%BD%91%E7%BB%9C%E4%B8%89-eBPF%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85/">网络三:eBPF解析数据包</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>