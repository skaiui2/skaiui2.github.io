<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>UDP协议 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">UDP协议</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">UDP协议</h1><div class="post-meta">2025-02-08</div><div class="post-content"><p>skaiuijing</p>
<p>UDP是一个无连接的协议。</p>
<p><strong>笔者使用的源码：lwip2.20版本，4.4BSD-lite，Linux内核2.6.24版本。</strong></p>
<p>lwip是一个轻量级的TCP&#x2F;IP实现，通常被使用在单片机这些资源受限的场景上，往往搭配RTOS使用。</p>
<p>4.4BSD-lite是一个跨时代的操作系统，TCP&#x2F;IP三卷中的协议栈源码就来自该操作系统。</p>
<p>Linux2.6是非常经典的版本，也是公认可商用版本。</p>
<h2 id="操作系统中的中断控制"><a href="#操作系统中的中断控制" class="headerlink" title="操作系统中的中断控制"></a>操作系统中的中断控制</h2><p>中断是操作系统中一个非常重要的概念，而协议栈往往作为操作系统的一部分，因此我们需要了解一些中断概念。</p>
<p>很多熟悉CPU架构的小伙伴都有过使用中断的经验，但中断也是有区别的，我们通常使用的是硬件层面的中断。</p>
<h3 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h3><p>一般由操作系统定义的中断，可由软件主动触发的中断，例如使用INT n指令触发该中断，这种被称之为软件中断。</p>
<p>我们执行的系统调用其实也是软件中断，通常执行软件中断时，程序会从用户态转变为内核态，</p>
<h3 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h3><p>硬件层面的中断，比如串口、网口中断，这些中断本质上是一种硬件资源。</p>
<h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>可以缓期执行的中断，软中断在适当的时候被内核调度执行，它本质上是由硬件触发。</p>
<h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><p>中断通常是外部触发，异常是内部触发，例如除0操作就会触发异常。但是在arm中，中断是异常的一种。</p>
<p>异常处理其实就是一种软件中断。</p>
<h3 id="软件触发的硬件中断"><a href="#软件触发的硬件中断" class="headerlink" title="软件触发的硬件中断"></a>软件触发的硬件中断</h3><p>我们可以往某个特定寄存器写入特殊值，这样就会触发中断执行，这种中断被称为软件触发的硬件中断，本质上还是硬件中断。</p>
<h3 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h3><p>我们都知道信息传递到硬件上是会触发中断接收信息的，但有些场合不能接收信息，此时，我们可以通过控制中断达到目的。</p>
<p>我们这里要屏蔽的中断是硬件中断和软件中断。</p>
<p>在RTOS中，lwip以线程的形式运行，通常是操作硬件的寄存器达到中断控制的目的，通常会屏蔽较低优先级的中断。</p>
<p>BSD中提供了不同的中断等级，可以通过调用不同的API实现屏蔽对应优先级以下的中断。</p>
<p>它的实现原理很简单，就是提高当前代码的优先级，从而达到屏蔽低优先级的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int s = splnet():提高优先级，屏蔽网络级别及以下优先级的中断，可以防止IP层对输入处理。</span><br><span class="line">....</span><br><span class="line">splx(s);//恢复到原先的优先级</span><br><span class="line">使用s保存变量的好处是可以嵌套使用。</span><br></pre></td></tr></table></figure>

<p>简单概述，一共两种实现：</p>
<p>1.设置一个优先级，低于该优先级的中断不得执行</p>
<p>2.提高程序优先级，这样低优先级的任务就不能打断当前程序</p>
<p>以上都是通过屏蔽中断方式实现程序的管理。</p>
<p>在Linux中，使用lock_sock这些锁实现对程序竞态的管理。通过对套接字（struct sock *sk）进行加锁，确保在对套接字的操作期间，不会发生竞态条件。在操作IP选项时，也通过rcu_read_lock()之类读写锁进行保护。甚至可以说，内核中大部分竞态问题都是通过锁解决的，例如内存锁、总线锁等等。</p>
<h2 id="网络输入输出"><a href="#网络输入输出" class="headerlink" title="网络输入输出"></a>网络输入输出</h2><p>网络输入如下，</p>
<p>网卡这些属于硬件资源，而硬件级别的中断是最高的优先级。产生硬件中断并使用splimp函数提高当前程序优先级，这样就可以确保传递信息给协议层之前没有干扰。因为如果此时网卡处理硬件输入，那么传递信息的程序会被打断，可能会插入其他数据到当前信息。如果硬件一直有输入，那么结果会是没有一个信息会传递到协议层，而就算只有一次打断，信息的完整性也会被破坏。</p>
<p>而协议层也是同理，触发软件中断并提升优先级，防止IP层处理输入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Aa(硬件接口层)--硬件中断与splimp调用--&gt;Ab(协议层)--软件中断与splnet调用--&gt;Ac(socket层)--&gt;Ad(进程)</span><br></pre></td></tr></table></figure>



<p>在TCP&#x2F;IP卷二中描述得非常奇怪，原文相关的内容是（<strong>硬件中断splimp</strong>），并且描述splimp这些函数的功能是提升CPU优先级。笔者不清楚是翻译的原因还是操作系统的区别，按照笔者个人理解splimp应该只是提升当前中断优先级的，splimp函数更不是硬件中断，它应该在网卡产生的硬件中断中使用才对。</p>
<p>网络上大部分文章都是照本宣科，笔者也没有找到答案。本文大部分内容均为个人理解，写错勿怪。</p>
<h2 id="应用层使用"><a href="#应用层使用" class="headerlink" title="应用层使用"></a>应用层使用</h2><p>通常我们调用API如下:</p>
<p>本文的socket指插口，也指套接字。</p>
<p>**创建套接字socket()**：无论是客户端还是服务器，首先需要创建一个套接字。</p>
<p><strong>（服务器）绑定套接字bind()：</strong>服务器需要绑定到一个固定的IP地址和端口，以便客户端能够找到它。</p>
<p><strong>（客户端）可选的绑定套接字：</strong>对于UDP客户端，通常不需要绑定套接字，系统会自动分配一个临时端口。</p>
<p><strong>发送和接收数据API，例如sendmsg() 和 recvmsg()：</strong>数据通信通过这两个函数完成，它们不需要建立连接即可发送和接收数据。</p>
<p><strong>关闭套接字close()：</strong>通信结束后，关闭套接字，释放系统资源。</p>
<p>代码实现如下：</p>
<p><strong>服务端建立</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;</span><br><span class="line">    char buffer[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    // 1. 创建 UDP 套接字</span><br><span class="line">    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) </span><br><span class="line">    // 2. 配置服务器地址</span><br><span class="line">    memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;          // IPv4</span><br><span class="line">    servaddr.sin_addr.s_addr = INADDR_ANY;  // 接收任意 IP</span><br><span class="line">    servaddr.sin_port = htons(PORT);        // 端口</span><br><span class="line">    // 3. 绑定套接字到指定端口</span><br><span class="line">    if (bind(sockfd, (const struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0 ) </span><br><span class="line">    while (1) &#123;</span><br><span class="line">        struct msghdr msg;</span><br><span class="line">        struct iovec iov;</span><br><span class="line">        char ctrl_buf[CMSG_SPACE(sizeof(int))]; // 控制信息缓冲区</span><br><span class="line">        struct cmsghdr *cmsg;</span><br><span class="line">        int n;</span><br><span class="line">        socklen_t len = sizeof(cliaddr);</span><br><span class="line">        // 4. 设置消息结构体</span><br><span class="line">        msg.msg_name = &amp;cliaddr;            // 存储客户端地址</span><br><span class="line">        msg.msg_namelen = sizeof(cliaddr);</span><br><span class="line">        msg.msg_iov = &amp;iov;</span><br><span class="line">        msg.msg_iovlen = 1;</span><br><span class="line">        msg.msg_control = ctrl_buf;         // 控制信息缓冲区</span><br><span class="line">        msg.msg_controllen = sizeof(ctrl_buf);</span><br><span class="line">        // 5. 接收消息</span><br><span class="line">        n = recvmsg(sockfd, &amp;msg, 0);</span><br><span class="line">        // 6. 发送回复消息</span><br><span class="line">        // 设置控制信息（例如设置 IP_TTL 为 64）</span><br><span class="line">        cmsg = CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">        cmsg-&gt;cmsg_level = IPPROTO_IP;</span><br><span class="line">        cmsg-&gt;cmsg_type = IP_TTL;</span><br><span class="line">        cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(int));</span><br><span class="line">        int ttl = 64;</span><br><span class="line">        memcpy(CMSG_DATA(cmsg), &amp;ttl, sizeof(ttl));</span><br><span class="line">        // 发送消息</span><br><span class="line">        if (sendmsg(sockfd, &amp;msg, 0) &lt; 0) </span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是我们调用API的流程，我们关注的是发送数据这里。</p>
<p>在BSD中，函数调用关系有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Aa(库函数send)--&gt;Ab(系统调用sendto)--&gt;Ac(sendit)--&gt;Ad(sosend)--&gt;Ae(udp_usrreq)--&gt;Af(udp_output)--&gt;D(ip_output)</span><br><span class="line">Ba(系统调用sendmsg)--&gt;Ac</span><br></pre></td></tr></table></figure>

<p>其中的UDP是我们感兴趣的部分，现在让我们看看具体实现，不过在此之前需要介绍一些基础数据结构。</p>
<p>首先介绍的是buf结构，在执行sosend函数时，会将用户空间拷贝待发送的数据到内核空间的缓冲区，用户数据被复制到mbuf中，由mbuf链表挂载分片的数据。</p>
<h2 id="pbuf、mbuf和skbuff"><a href="#pbuf、mbuf和skbuff" class="headerlink" title="pbuf、mbuf和skbuff"></a>pbuf、mbuf和skbuff</h2><p>在三种协议栈中，携带数据包的实现不同，但都采用链表形式。</p>
<p>pbuf是lwip的实现，作为一个轻量级协议栈，pbuf的结构体比较简单，但具有多种形式适用于不同场景。</p>
<p>mbuf是BSD的实现，通过小内存块和外部数据区域相结合，提高内存利用率，该实现强调内存效率和灵活性。</p>
<p>skbuff则是Linux的实现，采用引用计数机制，包含了数据包处理所需的各种元数据，如协议头部指针、时间戳、路由信息等，便于内核对数据包进行灵活操控。</p>
<p>skbuff的数据挂载具有两种实现，并使用union关键字修饰：一种是传统的链表，另一种是红黑树。</p>
<p>Linux中的协议栈实现是比较繁琐的，这与Linux是宏内核实现有关，协议栈中有大量的抽象层匹配，不过正因如此，Linux才能应对复杂的网络数据处理。</p>
<h3 id="mbuf"><a href="#mbuf" class="headerlink" title="mbuf"></a>mbuf</h3><p>mbuf共有四种，其中一种是mbuf簇。</p>
<h4 id="mbuf簇"><a href="#mbuf簇" class="headerlink" title="mbuf簇"></a>mbuf簇</h4><p>mbuf簇是一种固定大小的大块内存缓冲区，mbuf簇的大小通常为2KB或4KB，具体取决于系统的配置</p>
<h4 id="M-PREPEND函数"><a href="#M-PREPEND函数" class="headerlink" title="M_PREPEND函数"></a>M_PREPEND函数</h4><p>该函数用于在给定的 <code>mbuf</code> 链 <code>m</code> 的开头添加 <code>plen</code> 字节的空间，如果头部空间不足，那么就会分配一个新的mbuf（新的mbuf在旧的之前），这个机制也与分片有关。当数据报大于MTU（链路层最大传输）时，就会产生分片，一旦一个分片丢失，那么整个数据报都无效了，UDP常常产生分片，即使丢失，重发即可。但在TCP协议中，分片应该被避免，因为TCP协议会重传整个IP层，不仅仅是重发这么简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define M_PREPEND(m, plen, how) do &#123;                               \</span><br><span class="line">    if (M_LEADINGSPACE(m) &gt;= (plen)) &#123;                             \</span><br><span class="line">        (m)-&gt;m_data -= (plen);                                     \</span><br><span class="line">        (m)-&gt;m_len += (plen);                                      \</span><br><span class="line">        if ((m)-&gt;m_flags &amp; M_PKTHDR)                               \</span><br><span class="line">            (m)-&gt;m_pkthdr.len += (plen);                           \</span><br><span class="line">    &#125; else &#123;                                                       \</span><br><span class="line">        (m) = m_prepend((m), (plen), (how));                       \</span><br><span class="line">    &#125;                                                              \</span><br><span class="line">&#125; while (0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中M_LEADINGSPACE是计算mbuf簇前可用的空间，如果sosend函数将数据放到一个mbuf簇中，那么通常该簇前面有56个字节未使用，可以为IP，UDP等其他首部提供空间。</p>
<h3 id="mtod函数"><a href="#mtod函数" class="headerlink" title="mtod函数"></a>mtod函数</h3><p>该函数十分简单，就是指针类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define mtod(m, t)    ((t)((m)-&gt;m_data))</span><br></pre></td></tr></table></figure>

<p>在长篇大论UDP之前，我们先讲一讲IP报头结构：</p>
<h2 id="IP报头结构"><a href="#IP报头结构" class="headerlink" title="IP报头结构"></a>IP报头结构</h2><p>IP报头结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>版本&#x2F;头部长度</td>
<td>1</td>
</tr>
<tr>
<td>服务类型</td>
<td>1</td>
</tr>
<tr>
<td>总长度</td>
<td>2</td>
</tr>
<tr>
<td>标识</td>
<td>2</td>
</tr>
<tr>
<td>片偏移字段</td>
<td>2</td>
</tr>
<tr>
<td>生存时间（TTL）</td>
<td>1</td>
</tr>
<tr>
<td>协议</td>
<td>1</td>
</tr>
<tr>
<td>校验和</td>
<td>2</td>
</tr>
<tr>
<td>源IP地址</td>
<td>4</td>
</tr>
<tr>
<td>目的IP地址</td>
<td>4</td>
</tr>
</tbody></table>
<p>好了，现在该进入UDP了。</p>
<h2 id="报文首部结构体"><a href="#报文首部结构体" class="headerlink" title="报文首部结构体"></a>报文首部结构体</h2><p>报文首部通常有四个参数：源端口 、目的端口 、长度、校验和。</p>
<h2 id="UDP控制块"><a href="#UDP控制块" class="headerlink" title="UDP控制块"></a>UDP控制块</h2><p>UDP控制块会记录UDP通信的信息。</p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>根据协议规范，UDP布局如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度（位）</th>
</tr>
</thead>
<tbody><tr>
<td>**源端口 与 目的端口 **</td>
<td>都是2字节</td>
</tr>
<tr>
<td><strong>长度  与 校验和</strong></td>
<td>也都是2字节</td>
</tr>
<tr>
<td><strong>数据</strong></td>
<td>变长（最小可为0）</td>
</tr>
</tbody></table>
<p>前四个元素组成UDP头部。</p>
<p>在前文笔者给出了IP层的报文结构，对于IP层来说，发送给哪个传输层协议需要根据字段中的值进行判断，也就是服务类型，IP层根据这个值把数据报分离到特定的传输协议。</p>
<p>因此不同协议可以使用的端口号是独立的，不同的协议使用相同的端口号是不会冲突的。同样的，对于两个不同的服务器来说，只要它们使用不同的传输协议，那么它们可以使用相同的端口号和IP地址。</p>
<h2 id="UDP伪头部"><a href="#UDP伪头部" class="headerlink" title="UDP伪头部"></a>UDP伪头部</h2><table>
<thead>
<tr>
<th>字段</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>源IP地址</td>
<td>4字节</td>
</tr>
<tr>
<td>目的IP地址</td>
<td>4字节</td>
</tr>
<tr>
<td>全0</td>
<td>1字节</td>
</tr>
<tr>
<td>协议号</td>
<td>1字节</td>
</tr>
<tr>
<td>UDP长度</td>
<td>2字节</td>
</tr>
</tbody></table>
<p>UDP伪头部中的全0是协议规定需要填充的字段，确保UDP伪头部的大小是12字节。</p>
<p>UDP伪头部由IP首部构建而来，构建后的UDP伪头部下面是UDP头部和数据部分，数据部分后面可能会有一个填充值。</p>
<p>填充值的作用是字节对齐，这样方便计算校验和，因为校验和算法把所有内容视为一系列16位字。我们都知道字的大小基本由CPU的寻址大小决定（32位的CPU，字的大小往往是4字节，不过也可能由编译器决定），但是协议栈中的字的大小与CPU这些无关，固定为16位，也就是两字节，所以计算校验和必定需要偶数个字节。</p>
<p>数据部分后面的填充字节实际上不会被发送出去的（UDP伪头部也是），目的仅仅是辅助计算（如果数据报的长度是奇数那么就会填充该字节）。</p>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>UDP的校验和字段是端到端的，这意味着校验和的计算和验证都是在通信的<strong>发送端</strong>和<strong>接收端</strong>完成的，而中间的网络设备<strong>不参与</strong>这个过程。</p>
<p>（除非它通过一个NAT）</p>
<p>在<strong>IPv4</strong>中，UDP校验和是<strong>可选的</strong>，如果发送端未计算校验和，<strong>校验和字段可以填0</strong>，接收端则<strong>不会进行校验</strong>。</p>
<p>在<strong>IPv6</strong>中，UDP校验和是<strong>强制性的</strong>，必须进行计算和验证。</p>
<p>校验和是通过对UDP伪头部计算得到的（使用IP头部中的源IP地址和目的IP地址这些信息），也就是说，NAT在把私有IP地址转换为公有IP时，必须重新对UDP校验和进行修改。</p>
<h3 id="发送方校验"><a href="#发送方校验" class="headerlink" title="发送方校验"></a>发送方校验</h3><p>整理一下UDP伪头部相关的校验过程：</p>
<p><strong>初始化校验和字段</strong>：发送方首先将UDP首部中的校验和字段设置为0。</p>
<p><strong>构建校验和数据块</strong>：添加伪首部，如果数据报的长度是奇数那么就填充字节。</p>
<p><strong>计算校验和</strong>：将上述所有内容视为一系列16位字，将它们相加，采用二进制反码求和（即每次求和后取一位补码）。</p>
<p><strong>填写校验和字段</strong>：将计算得到的二进制反码和的反码（即取反）填入UDP首部的校验和字段。</p>
<h3 id="接收方校验"><a href="#接收方校验" class="headerlink" title="接收方校验"></a>接收方校验</h3><p><strong>构建校验和数据块</strong>：添加伪首部，如果数据报的长度是奇数那么就填充字节。</p>
<p><strong>计算校验和</strong>：方法同发送方校验。</p>
<p><strong>验证校验和</strong>：</p>
<p>将计算得到的校验和与0xFFFF（全1）比较：</p>
<p>如果结果为0xFFFF：表示数据完整，未检测到错误。</p>
<p>如果结果不为0xFFFF：表示数据在传输过程中发生了错误。</p>
<p><strong>处理数据报</strong>：</p>
<p>无错误：如果校验和验证通过，接收方可以将数据报交给上层应用程序处理。</p>
<p>有错误：如果校验和验证失败，接收方应丢弃该UDP数据报。</p>
<h2 id="UDP-Lite"><a href="#UDP-Lite" class="headerlink" title="UDP-Lite"></a>UDP-Lite</h2><p>传统的UDP要么启用校验覆盖全部数据，要么完全不启用（IPv4）。UDP-Lite通过修改传统的UDP协议，通过部分校验和来解决这个问题。结构体中会多出成员用以表示校验和覆盖范围。</p>
<p>例如lwip，以下参数来自struct udp_pcb：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if LWIP_UDPLITE</span><br><span class="line">  /** used for UDP_LITE only */</span><br><span class="line">  u16_t chksum_len_rx, chksum_len_tx;</span><br><span class="line">#endif /* LWIP_UDPLITE */</span><br></pre></td></tr></table></figure>

<p>这两个参数分别表示接收和发送时的校验和覆盖范围。</p>
<p>简单表示如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>源端口号</td>
<td>2字节</td>
</tr>
<tr>
<td>目的端口号</td>
<td>2字节</td>
</tr>
<tr>
<td>校验和覆盖范围</td>
<td>2字节</td>
</tr>
<tr>
<td>校验和</td>
<td>2字节</td>
</tr>
</tbody></table>
<p>覆盖范围是被覆盖的字节数，是从UDP-Lite头部的第一个参数开始。该参数除了特殊的值0外，最小值是8（字节），因为头部肯定是要被覆盖的。当值为0时，表示全覆盖，等效于传统的UDP协议开启校验。</p>
<h2 id="lwip实现"><a href="#lwip实现" class="headerlink" title="lwip实现"></a>lwip实现</h2><h3 id="IP结构体"><a href="#IP结构体" class="headerlink" title="IP结构体"></a>IP结构体</h3><p>lwip中定义结构体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct ip_hdr &#123;</span><br><span class="line">  /* version / header length */</span><br><span class="line">  PACK_STRUCT_FLD_8(u8_t _v_hl);</span><br><span class="line">  /* type of service */</span><br><span class="line">  PACK_STRUCT_FLD_8(u8_t _tos);</span><br><span class="line">  /* total length */</span><br><span class="line">  PACK_STRUCT_FIELD(u16_t _len);</span><br><span class="line">  /* identification */</span><br><span class="line">  PACK_STRUCT_FIELD(u16_t _id);</span><br><span class="line">  /* fragment offset field */</span><br><span class="line">  PACK_STRUCT_FIELD(u16_t _offset);</span><br><span class="line">#define IP_RF 0x8000U        /* reserved fragment flag */</span><br><span class="line">#define IP_DF 0x4000U        /* don&#x27;t fragment flag */</span><br><span class="line">#define IP_MF 0x2000U        /* more fragments flag */</span><br><span class="line">#define IP_OFFMASK 0x1fffU   /* mask for fragmenting bits */</span><br><span class="line">  /* time to live */</span><br><span class="line">  PACK_STRUCT_FLD_8(u8_t _ttl);</span><br><span class="line">  /* protocol*/</span><br><span class="line">  PACK_STRUCT_FLD_8(u8_t _proto);</span><br><span class="line">  /* checksum */</span><br><span class="line">  PACK_STRUCT_FIELD(u16_t _chksum);</span><br><span class="line">  /* source and destination IP addresses */</span><br><span class="line">  PACK_STRUCT_FLD_S(ip4_addr_p_t src);</span><br><span class="line">  PACK_STRUCT_FLD_S(ip4_addr_p_t dest);</span><br><span class="line">&#125; PACK_STRUCT_STRUCT;</span><br></pre></td></tr></table></figure>



<h3 id="UDP结构体"><a href="#UDP结构体" class="headerlink" title="UDP结构体"></a>UDP结构体</h3><p>在lwip中定义的UDP报文首部数据结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct udp_hdr&#123;</span><br><span class="line">	uint16_t src;</span><br><span class="line">	uint16_t dest;</span><br><span class="line">	uint16_t len;</span><br><span class="line">	uint16_t chksum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>lwip中udp控制块定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct udp_pcb &#123;</span><br><span class="line">/** Common members of all PCB types */</span><br><span class="line">  IP_PCB;</span><br><span class="line"></span><br><span class="line">/* Protocol specific PCB members */</span><br><span class="line"></span><br><span class="line">  struct udp_pcb *next;</span><br><span class="line"></span><br><span class="line">  u8_t flags;</span><br><span class="line">  /** ports are in host byte order */</span><br><span class="line">  u16_t local_port, remote_port;</span><br><span class="line"></span><br><span class="line">#if LWIP_MULTICAST_TX_OPTIONS</span><br><span class="line">#if LWIP_IPV4</span><br><span class="line"> //指定多播数据包的传出网络接口的IPv4地址</span><br><span class="line">  ip4_addr_t mcast_ip4;</span><br><span class="line">#endif /* LWIP_IPV4 */</span><br><span class="line">  //指定物理接口</span><br><span class="line">  u8_t mcast_ifindex;</span><br><span class="line">  //多播数据包的生存时间，即被丢弃前可经过的最大路由跳数</span><br><span class="line">  u8_t mcast_ttl;</span><br><span class="line">#endif </span><br><span class="line"></span><br><span class="line">#if LWIP_UDPLITE</span><br><span class="line">  //仅用于UDP_LITE的校验</span><br><span class="line">  u16_t chksum_len_rx, chksum_len_tx;</span><br><span class="line">#endif /* LWIP_UDPLITE */</span><br><span class="line"></span><br><span class="line">  /** receive callback function */</span><br><span class="line">  udp_recv_fn recv;</span><br><span class="line">  /** user-supplied argument for the recv callback */</span><br><span class="line">  void *recv_arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IP_PCB控制块结构体定义，准确来说，它是所有控制块的父类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/** This is the common part of all PCB types. It needs to be at the</span><br><span class="line">   beginning of a PCB type definition. It is located here so that</span><br><span class="line">   changes to this common part are made in one location instead of</span><br><span class="line">   having to change all PCB structs. */</span><br><span class="line">#define IP_PCB                             \</span><br><span class="line">  /* ip addresses in network byte order */ \</span><br><span class="line">  ip_addr_t local_ip;                      \</span><br><span class="line">  ip_addr_t remote_ip;                     \</span><br><span class="line">  /* Bound netif index */                  \</span><br><span class="line">  u8_t netif_idx;                          \</span><br><span class="line">  /* Socket options */                     \</span><br><span class="line">  u8_t so_options;                         \</span><br><span class="line">  /* Type Of Service */                    \</span><br><span class="line">  u8_t tos;                                \</span><br><span class="line">  /* Time To Live */                       \</span><br><span class="line">  u8_t ttl                                 \</span><br><span class="line">  /* link layer address resolution hint */ \</span><br><span class="line">  IP_PCB_NETIFHINT</span><br></pre></td></tr></table></figure>

<p>在RTOS中，线程取代了进程，应用线程持有特定的端口号，当UDP收到一个报文时，会对链表上的PCB进行遍历并匹配本地持有特定端口号的UDP控制块。</p>
<p>UDP控制块中的callbak函数会在lwip接收数据时被调用，它与recv字段有关。</p>
<h3 id="UDP发送"><a href="#UDP发送" class="headerlink" title="UDP发送"></a>UDP发送</h3><p>从线程发送的数据会被udp_sendto_if_src进行处理,最后转交到IP层（如果不出意外的话）。</p>
<p>发送函数如下：</p>
<p>其实就是先检查几遍，再把UDP首部添加到pbuf中，然后填写UDP各个字段，最后输出到IP层。</p>
<p>1.判断套接字是否绑定本地端口，如果没有则进行绑定</p>
<p>2.判断数据包是否太大，导致无法添加首部，如果pbuf中没有足够的空间，那么就再申请一个pbuf</p>
<p>3.获取pbuf地址，填写udp_hdr的四个成员</p>
<p>4.如果设置了多播选项，多播循环被启用且目标地址是多播地址时，设置标志位</p>
<p>5.设置生存时间（其实这里省略了非常多的宏定义及代码），并输出数据报到IP层</p>
<p>6.如果额外申请了pbuf存放首部，在输出到IP层后可以回收该首部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/** @ingroup udp_raw</span><br><span class="line"> * Same as @ref udp_sendto_if, but with source address */</span><br><span class="line">err_t</span><br><span class="line">udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,</span><br><span class="line">                  const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *src_ip)</span><br><span class="line">&#123;</span><br><span class="line">  struct udp_hdr *udphdr;</span><br><span class="line">  err_t err;</span><br><span class="line">  struct pbuf *q; /* q will be sent down the stack */</span><br><span class="line">  u8_t ip_proto;</span><br><span class="line">  u8_t ttl;</span><br><span class="line"></span><br><span class="line">  /* if the PCB is not yet bound to a port, bind it here */</span><br><span class="line">  if (pcb-&gt;local_port == 0) &#123;</span><br><span class="line">    err = udp_bind(pcb, &amp;pcb-&gt;local_ip, pcb-&gt;local_port);</span><br><span class="line">    if (err != ERR_OK) &#123;</span><br><span class="line">      return err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* packet too large to add a UDP header without causing an overflow? */</span><br><span class="line">  if ((u16_t)(p-&gt;tot_len + UDP_HLEN) &lt; p-&gt;tot_len) &#123;</span><br><span class="line">    return ERR_MEM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* not enough space to add an UDP header to first pbuf in given p chain? */</span><br><span class="line">  if (pbuf_add_header(p, UDP_HLEN)) &#123;</span><br><span class="line">    /* allocate header in a separate new pbuf */</span><br><span class="line">    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);</span><br><span class="line">    if (q == NULL) &#123;</span><br><span class="line">      return ERR_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p-&gt;tot_len != 0) &#123;</span><br><span class="line">      /* chain header q in front of given pbuf p */</span><br><span class="line">      pbuf_chain(q, p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    q = p;</span><br><span class="line">  &#125;</span><br><span class="line">  udphdr = (struct udp_hdr *)q-&gt;payload;</span><br><span class="line">  udphdr-&gt;src = lwip_htons(pcb-&gt;local_port);</span><br><span class="line">  udphdr-&gt;dest = lwip_htons(dst_port);</span><br><span class="line">  udphdr-&gt;chksum = 0x0000;</span><br><span class="line"></span><br><span class="line">/* Multicast Loop? */</span><br><span class="line">#if LWIP_MULTICAST_TX_OPTIONS</span><br><span class="line">  if (((pcb-&gt;flags &amp; UDP_FLAGS_MULTICAST_LOOP) != 0) &amp;&amp; ip_addr_ismulticast(dst_ip)) &#123;</span><br><span class="line">    q-&gt;flags |= PBUF_FLAG_MCASTLOOP;</span><br><span class="line">  &#125;</span><br><span class="line">#endif /* LWIP_MULTICAST_TX_OPTIONS */</span><br><span class="line"></span><br><span class="line">  /* Determine TTL to use */</span><br><span class="line">  ttl = pcb-&gt;ttl;</span><br><span class="line">  </span><br><span class="line">  /* output to IP */</span><br><span class="line">  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb-&gt;tos, IP_PROTO_UDP, netif);</span><br><span class="line"></span><br><span class="line">  if (q != p) &#123;</span><br><span class="line">    pbuf_free(q);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="UDP接收"><a href="#UDP接收" class="headerlink" title="UDP接收"></a>UDP接收</h2><p>从IP层接收的数据会被UDP_input进行处理,最后转交到线程（如果不出意外的话）。</p>
<p>接收函数：</p>
<p>1.检查长度，如果PCB中记录UDP头部长度小于8字节，那么程序报错</p>
<p>2.迭代PCB，找到符合的端口号，如果没有，就使用第一个端口。</p>
<p>具体实现逻辑：判断uncon_pcb为NULL时，使用指针uncon_pcb保存的pcb。因为uncon_pcb被初始化为NULL，程序只有第一次会保存，那么uncon_pcb一定是第一个迭代到的pcb。如果到链表尾部都没找到，循环判断pcb为NULL并终止，那么就赋值pcb为uncon_pcb。</p>
<p>3.找到对应的控制块后，使用callback函数递交给具体线程应用。</p>
<p>4.如果找不到对应控制块，这种情况说明链表上没有pcb，如果启用了ICMP选项，那么返回端口不可达ICMP报文。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">接收函数有点长，所以笔者删除了一些条件编译和不重要的注释。</span><br><span class="line">/**</span><br><span class="line"> * If no pcb is found or the datagram is incorrect, the</span><br><span class="line"> * pbuf is freed.</span><br><span class="line"> * @param p pbuf to be demultiplexed to a UDP PCB (p-&gt;payload pointing to the UDP header)</span><br><span class="line"> * @param inp network interface on which the datagram was received.</span><br><span class="line"> */</span><br><span class="line">void</span><br><span class="line">udp_input(struct pbuf *p, struct netif *inp)</span><br><span class="line">&#123;</span><br><span class="line">  struct udp_hdr *udphdr;</span><br><span class="line">  struct udp_pcb *pcb, *prev;</span><br><span class="line">  struct udp_pcb *uncon_pcb;</span><br><span class="line">  u16_t src, dest;</span><br><span class="line">  u8_t broadcast;</span><br><span class="line">  u8_t for_us = 0;</span><br><span class="line"></span><br><span class="line">  /* Check minimum length (UDP header) */</span><br><span class="line">  if (p-&gt;len &lt; UDP_HLEN) &#123;</span><br><span class="line">    pbuf_free(p);</span><br><span class="line">    goto end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  udphdr = (struct udp_hdr *)p-&gt;payload;</span><br><span class="line"></span><br><span class="line">  /* is broadcast packet ? */</span><br><span class="line">  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());</span><br><span class="line"></span><br><span class="line">  /* convert src and dest ports to host byte order */</span><br><span class="line">  src = lwip_ntohs(udphdr-&gt;src);</span><br><span class="line">  dest = lwip_ntohs(udphdr-&gt;dest);</span><br><span class="line"></span><br><span class="line">  pcb = NULL;</span><br><span class="line">  prev = NULL;</span><br><span class="line">  uncon_pcb = NULL;</span><br><span class="line"></span><br><span class="line">  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb-&gt;next) &#123;</span><br><span class="line">    /* compare PCB local addr+port to UDP destination addr+port */</span><br><span class="line">    if ((pcb-&gt;local_port == dest) &amp;&amp;</span><br><span class="line">        (udp_input_local_match(pcb, inp, broadcast) != 0)) &#123;</span><br><span class="line">      if ((pcb-&gt;flags &amp; UDP_FLAGS_CONNECTED) == 0) &#123;</span><br><span class="line">        if (uncon_pcb == NULL) &#123;</span><br><span class="line">          /* the first unconnected matching PCB */</span><br><span class="line">          uncon_pcb = pcb;</span><br><span class="line">#if LWIP_IPV4</span><br><span class="line">        &#125; else if (broadcast &amp;&amp; ip4_current_dest_addr()-&gt;addr == IPADDR_BROADCAST) &#123;</span><br><span class="line">          /* global broadcast address (only valid for IPv4; match was checked before) */</span><br><span class="line">          if (!IP_IS_V4_VAL(uncon_pcb-&gt;local_ip) || !ip4_addr_eq(ip_2_ip4(&amp;uncon_pcb-&gt;local_ip), netif_ip4_addr(inp))) &#123;</span><br><span class="line">            /* uncon_pcb does not match the input netif, check this pcb */</span><br><span class="line">            if (IP_IS_V4_VAL(pcb-&gt;local_ip) &amp;&amp; ip4_addr_eq(ip_2_ip4(&amp;pcb-&gt;local_ip), netif_ip4_addr(inp))) &#123;</span><br><span class="line">              /* better match */</span><br><span class="line">              uncon_pcb = pcb;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">#endif /* LWIP_IPV4 */</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /* compare PCB remote addr+port to UDP source addr+port */</span><br><span class="line">      if ((pcb-&gt;remote_port == src) &amp;&amp;</span><br><span class="line">          (ip_addr_isany_val(pcb-&gt;remote_ip) ||</span><br><span class="line">           ip_addr_eq(&amp;pcb-&gt;remote_ip, ip_current_src_addr()))) &#123;</span><br><span class="line">        /* the first fully matching PCB */</span><br><span class="line">        if (prev != NULL) &#123;</span><br><span class="line">          /* move the pcb to the front of udp_pcbs so that is</span><br><span class="line">             found faster next time */</span><br><span class="line">          prev-&gt;next = pcb-&gt;next;</span><br><span class="line">          pcb-&gt;next = udp_pcbs;</span><br><span class="line">          udp_pcbs = pcb;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          UDP_STATS_INC(udp.cachehit);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prev = pcb;</span><br><span class="line">  &#125;</span><br><span class="line">  /* no fully matching pcb found? then look for an unconnected pcb */</span><br><span class="line">  if (pcb == NULL) &#123;</span><br><span class="line">    pcb = uncon_pcb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* Check checksum if this is a match or if it was directed at us. */</span><br><span class="line">  if (pcb != NULL) &#123;</span><br><span class="line">    for_us = 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">#if LWIP_IPV4</span><br><span class="line">    if (!ip_current_is_v6()) &#123;</span><br><span class="line">      for_us = ip4_addr_eq(netif_ip4_addr(inp), ip4_current_dest_addr());</span><br><span class="line">    &#125;</span><br><span class="line">#endif /* LWIP_IPV4 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (for_us) &#123;</span><br><span class="line">#if LWIP_UDPLITE</span><br><span class="line">      if (ip_current_header_proto() == IP_PROTO_UDPLITE) &#123;</span><br><span class="line">        /* Do the UDP Lite checksum */</span><br><span class="line">        u16_t chklen = lwip_ntohs(udphdr-&gt;len);</span><br><span class="line">        if (chklen &lt; sizeof(struct udp_hdr)) &#123;</span><br><span class="line">          if (chklen == 0) &#123;</span><br><span class="line">            /* For UDP-Lite, checksum length of 0 means checksum</span><br><span class="line">               over the complete packet (See RFC 3828 chap. 3.1) */</span><br><span class="line">            chklen = p-&gt;tot_len;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            /* At least the UDP-Lite header must be covered by the</span><br><span class="line">               checksum! (Again, see RFC 3828 chap. 3.1) */</span><br><span class="line">            goto chkerr;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip_chksum_pseudo_partial(p, IP_PROTO_UDPLITE,</span><br><span class="line">                                     p-&gt;tot_len, chklen,</span><br><span class="line">                                     ip_current_src_addr(), 		 </span><br><span class="line">                                     ip_current_dest_addr()) != 0) &#123;</span><br><span class="line">          goto chkerr;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else</span><br><span class="line">#endif /* LWIP_UDPLITE */</span><br><span class="line">    if (pbuf_remove_header(p, UDP_HLEN)) &#123;</span><br><span class="line">      pbuf_free(p);</span><br><span class="line">      goto end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pcb != NULL) &#123;</span><br><span class="line">      /* callback */</span><br><span class="line">      if (pcb-&gt;recv != NULL) &#123;</span><br><span class="line">        /* now the recv function is responsible for freeing p */</span><br><span class="line">        pcb-&gt;recv(pcb-&gt;recv_arg, pcb, p, ip_current_src_addr(), src);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        /* no recv function registered? then we have to free the pbuf! */</span><br><span class="line">        pbuf_free(p);</span><br><span class="line">        goto end;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">#if LWIP_ICMP || LWIP_ICMP6</span><br><span class="line">      /* No match was found, send ICMP destination port unreachable unless</span><br><span class="line">         destination address was broadcast/multicast. */</span><br><span class="line">      if (!broadcast &amp;&amp; !ip_addr_ismulticast(ip_current_dest_addr())) &#123;</span><br><span class="line">        /* move payload pointer back to ip header */</span><br><span class="line">        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));</span><br><span class="line">        icmp_port_unreach(ip_current_is_v6(), p);</span><br><span class="line">      &#125;</span><br><span class="line">#endif /* LWIP_ICMP || LWIP_ICMP6 */</span><br><span class="line">      pbuf_free(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    pbuf_free(p);</span><br><span class="line">  &#125;</span><br><span class="line">end:</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="BSD实现"><a href="#BSD实现" class="headerlink" title="BSD实现"></a>BSD实现</h2><p>在BSD中UDP头部数据结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Udp protocol header.</span><br><span class="line"> * Per RFC 768, September, 1981.</span><br><span class="line"> */</span><br><span class="line">struct udphdr &#123;</span><br><span class="line">	u_short	uh_sport;		/* source port */</span><br><span class="line">	u_short	uh_dport;		/* destination port */</span><br><span class="line">	short	uh_ulen;		/* udp length */</span><br><span class="line">	u_short	uh_sum;			/* udp checksum */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IP首部实现可以参考lwip，不过笔者简单讲一讲一个相似的结构体struct ipovly。</p>
<p>struct ipovly是在BSD内部使用的一个覆盖IP首部之上的结构，其实并不是真正的IP首部，这是为了方便计算校验和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Overlay for ip header used by other protocols (tcp, udp).</span><br><span class="line"> */</span><br><span class="line">struct ipovly &#123;</span><br><span class="line">	caddr_t	ih_next, ih_prev;	/* for protocol sequence q&#x27;s */</span><br><span class="line">	u_char	ih_x1;			/* (unused) */</span><br><span class="line">	u_char	ih_pr;			/* protocol */</span><br><span class="line">	short	ih_len;			/* protocol length */</span><br><span class="line">	struct	in_addr ih_src;		/* source internet address */</span><br><span class="line">	struct	in_addr ih_dst;		/* destination internet address */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>IP&#x2F;UDP首部结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * UDP kernel structures and variables.</span><br><span class="line"> */</span><br><span class="line">struct	udpiphdr &#123;</span><br><span class="line">	struct 	ipovly ui_i;		/* overlaid ip structure */</span><br><span class="line">	struct	udphdr ui_u;		/* udp header */</span><br><span class="line">&#125;;</span><br><span class="line">#define	ui_next		ui_i.ih_next</span><br><span class="line">#define	ui_prev		ui_i.ih_prev</span><br><span class="line">#define	ui_x1		ui_i.ih_x1</span><br><span class="line">#define	ui_pr		ui_i.ih_pr</span><br><span class="line">#define	ui_len		ui_i.ih_len</span><br><span class="line">#define	ui_src		ui_i.ih_src</span><br><span class="line">#define	ui_dst		ui_i.ih_dst</span><br><span class="line">#define	ui_sport	ui_u.uh_sport</span><br><span class="line">#define	ui_dport	ui_u.uh_dport</span><br><span class="line">#define	ui_ulen		ui_u.uh_ulen</span><br><span class="line">#define	ui_sum		ui_u.uh_sum</span><br></pre></td></tr></table></figure>



<h3 id="UDP发送-1"><a href="#UDP发送-1" class="headerlink" title="UDP发送"></a>UDP发送</h3><p>UDP发送实现简单介绍如下：</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>inp：UDP 套接字在内核中的表示，包含了套接字的所有状态和配置信息，例如IP&#x2F;UDP首部等信息</p>
<p>m：指向输出mbuf链</p>
<p>addr：一个可选指针，指向sockaddr_in结构中的目的地址</p>
<p>control：一个可选指针，指向sendmsg的控制信息</p>
<h4 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h4><p>1.如果我们没有使用sendmsg这些带控制信息的API，那么就丢弃control参数。</p>
<p>2.指定了目的地址：判断套接字传递过来的目的地址是不是任意地址（0.0.0.0），如果是，那么该地址无意义，返回错误。如果不是，需要通过in_pcbconnect函数临时连接到该目的地址，不过在连接之前需要暂时提升当前程序优先级并保存本地地址。因为临时连接会改变套接字中的外部地址、端口和本地地址， 此时的套接字信息是不完整的。如果此时有 UDP 数据报到达，协议栈在查找匹配的套接字时，可能因地址信息变化而将数据报交给错误的套接字，导致数据被错误的进程接收。</p>
<p>未指定目的地址：判断是不是已经连接上了（例如调用 <code>connect()</code> 函数实现连接），否则也报错。</p>
<p><code>connect()</code> 函数的本质也是调用in_pcbconnect函数。</p>
<p>3.关于M_PREPEND和mtod可以看mbuf那一节。程序先申请内存，再设置IP&#x2F;UDP首部，接下来就是计算校验和。</p>
<p>4.检验与计算校验和，在前文笔者简单介绍过校验和的计算，分为初始化、构建、计算、填写四个步骤，读者可以返回前文查看。</p>
<p>初始化与构建：将IP首部覆盖为ui_next，ui-&gt;ui_prev，并覆盖其他参数，这两个参数不会影响校验和结果，因为它们被设置为0。现在IP首部被覆盖为：ui_next，ui_prev，ui_x1，ui_pr，ui_len。其中IP首部中的ui_len、ui_src和ui_dst是真正影响校验和结果的参数。计算和填写就不多赘述了，是通过in_cksum实现的。</p>
<p>正如我们前面所说的，UDP的IPv4是允许不进行校验的，只要把校验和填0。而如果计算出来的结果是0，校验和会填写为0xffff。</p>
<p>5.udp_output会填充IP头部的三个字段：服务类型TOS、全长len、生存时间TTL，而ip_output则会填充其他字段。</p>
<p>6.使用ip_output发送数据报。</p>
<p>7.如果socket是临时连接上的，那么调用in_pcbdisconnect断连临时连接的socket，同时恢复本地地址并恢复程序优先级，之后程序结束。</p>
<p>其中in_pcbconnect将会耗费程序近三分之一的时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">int udp_output(inp, m, addr, control)</span><br><span class="line">	register struct inpcb *inp;</span><br><span class="line">	register struct mbuf *m;</span><br><span class="line">	struct mbuf *addr, *control;</span><br><span class="line">&#123;</span><br><span class="line">	register struct udpiphdr *ui;</span><br><span class="line">	register int len = m-&gt;m_pkthdr.len;</span><br><span class="line">	struct in_addr laddr;</span><br><span class="line">	int s, error = 0;</span><br><span class="line"></span><br><span class="line">	if (control)</span><br><span class="line">		m_freem(control);		/* XXX */</span><br><span class="line"></span><br><span class="line">	if (addr) &#123;</span><br><span class="line">		laddr = inp-&gt;inp_laddr;</span><br><span class="line">		if (inp-&gt;inp_faddr.s_addr != INADDR_ANY) &#123;</span><br><span class="line">			error = EISCONN;</span><br><span class="line">			goto release;</span><br><span class="line">		&#125;</span><br><span class="line">		/*</span><br><span class="line">		 * Must block input while temporarily connected.</span><br><span class="line">		 */</span><br><span class="line">		s = splnet();</span><br><span class="line">		error = in_pcbconnect(inp, addr);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			splx(s);</span><br><span class="line">			goto release;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (inp-&gt;inp_faddr.s_addr == INADDR_ANY) &#123;</span><br><span class="line">			error = ENOTCONN;</span><br><span class="line">			goto release;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * Calculate data length and get a mbuf</span><br><span class="line">	 * for UDP and IP headers.</span><br><span class="line">	 */</span><br><span class="line">	M_PREPEND(m, sizeof(struct udpiphdr), M_DONTWAIT);</span><br><span class="line">	if (m == 0) &#123;</span><br><span class="line">		error = ENOBUFS;</span><br><span class="line">		goto release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Fill in mbuf with extended UDP header</span><br><span class="line">	 * and addresses and length put into network format.</span><br><span class="line">	 */</span><br><span class="line">	ui = mtod(m, struct udpiphdr *);</span><br><span class="line">	ui-&gt;ui_next = ui-&gt;ui_prev = 0;</span><br><span class="line">	ui-&gt;ui_x1 = 0;</span><br><span class="line">	ui-&gt;ui_pr = IPPROTO_UDP;</span><br><span class="line">	ui-&gt;ui_len = htons((u_short)len + sizeof (struct udphdr));</span><br><span class="line">	ui-&gt;ui_src = inp-&gt;inp_laddr;</span><br><span class="line">	ui-&gt;ui_dst = inp-&gt;inp_faddr;</span><br><span class="line">	ui-&gt;ui_sport = inp-&gt;inp_lport;</span><br><span class="line">	ui-&gt;ui_dport = inp-&gt;inp_fport;</span><br><span class="line">	ui-&gt;ui_ulen = ui-&gt;ui_len;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Stuff checksum and output datagram.</span><br><span class="line">	 */</span><br><span class="line">	ui-&gt;ui_sum = 0;</span><br><span class="line">	if (udpcksum) &#123;</span><br><span class="line">	    if ((ui-&gt;ui_sum = in_cksum(m, sizeof (struct udpiphdr) + len)) == 0)</span><br><span class="line">		ui-&gt;ui_sum = 0xffff;</span><br><span class="line">	&#125;</span><br><span class="line">	((struct ip *)ui)-&gt;ip_len = sizeof (struct udpiphdr) + len;</span><br><span class="line">	((struct ip *)ui)-&gt;ip_ttl = inp-&gt;inp_ip.ip_ttl;	/* XXX */</span><br><span class="line">	((struct ip *)ui)-&gt;ip_tos = inp-&gt;inp_ip.ip_tos;	/* XXX */</span><br><span class="line">	udpstat.udps_opackets++;</span><br><span class="line">	error = ip_output(m, inp-&gt;inp_options, &amp;inp-&gt;inp_route,</span><br><span class="line">	    inp-&gt;inp_socket-&gt;so_options &amp; (SO_DONTROUTE | SO_BROADCAST),</span><br><span class="line">	    inp-&gt;inp_moptions);</span><br><span class="line"></span><br><span class="line">	if (addr) &#123;</span><br><span class="line">		in_pcbdisconnect(inp);</span><br><span class="line">		inp-&gt;inp_laddr = laddr;</span><br><span class="line">		splx(s);</span><br><span class="line">	&#125;</span><br><span class="line">	return (error);</span><br><span class="line"></span><br><span class="line">release:</span><br><span class="line">	m_freem(m);</span><br><span class="line">	return (error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="UDP输入"><a href="#UDP输入" class="headerlink" title="UDP输入"></a>UDP输入</h3><p>输入函数的目标是把UDP数据报放到合适的插口缓存内，然后唤醒该插口上因输入阻塞的所有进程或线程（唤醒需要依靠操作系统的IPC机制）。</p>
<p>分为三个步骤：</p>
<p>1.确认消息并简单处理输入的数据</p>
<p>2.处理目的地址是单播类型的数据报：提交给单个socket即可</p>
<p>3.处理目的地址是广播或多播类型的数据报：需要找到所有需要提交的socket</p>
<p>处理输入的代码如下：</p>
<p>代码主要是验证数据报长度，有两个参数：ip_len 与 uh_ulen，这两个参数都表示数据报长度，正常情况下，它们应该是相等的。</p>
<p>正常情况：</p>
<p>uh_ulen：UDP首部加UDP数据长度</p>
<p>ip_len：数据报内容长度</p>
<p>但我们都知道网络结构是分层的，下一层对上一层来说就是内容，所以有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Ba(UDP首部)--&gt;Bb(UDP数据)</span><br><span class="line">Aa(IP首部)--ip_len--&gt;Ab(UDP首部)--&gt;Ac(UDP数据)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>ip_len 大于 uh_ulen：代码相信小的那个，也就是uh_ulen，此时调用m_adj丢弃mbuf后面多出来的部分，在校验和检验时会丢弃该数据报。</p>
<p>ip_len 小于 uh_ulen：长度出现严重错误，数据报必须立即被丢弃。</p>
<p>后面就是填写字段并计算校验和，在前文讲过了，就不过多赘述了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">void udp_input(m, iphlen)</span><br><span class="line">	register struct mbuf *m;</span><br><span class="line">	int iphlen;</span><br><span class="line">&#123;</span><br><span class="line">	register struct ip *ip;</span><br><span class="line">	register struct udphdr *uh;</span><br><span class="line">	register struct inpcb *inp;</span><br><span class="line">	struct mbuf *opts = 0;</span><br><span class="line">	int len;</span><br><span class="line">	struct ip save_ip;</span><br><span class="line"></span><br><span class="line">	udpstat.udps_ipackets++;</span><br><span class="line">	//此时还没有实现备份IP选项，因此需要丢弃</span><br><span class="line">	if (iphlen &gt; sizeof (struct ip)) &#123;</span><br><span class="line">		ip_stripoptions(m, (struct mbuf *)0);</span><br><span class="line">		iphlen = sizeof(struct ip);</span><br><span class="line">	&#125;</span><br><span class="line">	//如果IP/UDP长度不合理，那么重新安排mbuf链，使第一个mbuf至少有28个字节</span><br><span class="line">	ip = mtod(m, struct ip *);</span><br><span class="line">	if (m-&gt;m_len &lt; iphlen + sizeof(struct udphdr)) &#123;</span><br><span class="line">		if ((m = m_pullup(m, iphlen + sizeof(struct udphdr))) == 0) &#123;</span><br><span class="line">			udpstat.udps_hdrops++;//状态标志位，这些代码不影响理解</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		ip = mtod(m, struct ip *);</span><br><span class="line">	&#125;</span><br><span class="line">	uh = (struct udphdr *)((caddr_t)ip + iphlen);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Make mbuf data length reflect UDP length.</span><br><span class="line">	 * If not enough data to reflect UDP length, drop.</span><br><span class="line">	 */</span><br><span class="line">	len = ntohs((u_short)uh-&gt;uh_ulen);</span><br><span class="line">	if (ip-&gt;ip_len != len) &#123;</span><br><span class="line">		if (len &gt; ip-&gt;ip_len) &#123;</span><br><span class="line">			udpstat.udps_badlen++;</span><br><span class="line">			goto bad;</span><br><span class="line">		&#125;</span><br><span class="line">		m_adj(m, len - ip-&gt;ip_len);</span><br><span class="line">		/* ip-&gt;ip_len = len; */</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * Save a copy of the IP header in case we want restore it</span><br><span class="line">	 * for sending an ICMP error message in response.</span><br><span class="line">	 */</span><br><span class="line">	save_ip = *ip;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Checksum extended UDP header and data.</span><br><span class="line">	 */</span><br><span class="line">	if (udpcksum &amp;&amp; uh-&gt;uh_sum) &#123;</span><br><span class="line">		((struct ipovly *)ip)-&gt;ih_next = 0;</span><br><span class="line">		((struct ipovly *)ip)-&gt;ih_prev = 0;</span><br><span class="line">		((struct ipovly *)ip)-&gt;ih_x1 = 0;</span><br><span class="line">		((struct ipovly *)ip)-&gt;ih_len = uh-&gt;uh_ulen;</span><br><span class="line">		if (uh-&gt;uh_sum = in_cksum(m, len + sizeof (struct ip))) &#123;</span><br><span class="line">			udpstat.udps_badsum++;</span><br><span class="line">			m_freem(m);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	后面的程序依次是：</span><br><span class="line">	分用多播和广播数据报</span><br><span class="line">	分用单播数据报</span><br><span class="line">	生成ICMP端口不可达差错</span><br></pre></td></tr></table></figure>





<h4 id="分用多播和广播数据报"><a href="#分用多播和广播数据报" class="headerlink" title="分用多播和广播数据报"></a>分用多播和广播数据报</h4><p>与单播相比，多播与广播需要提交数据报给所有匹配的socket，其他的操作其实大同小异，读者可以参考下文的单播。但是，其中的难点就在于数据报的提交与回收。</p>
<p>实现逻辑：迭代遍历pcb，如果pcb不匹配，就使用continue关键字开启下一轮迭代，直到找到匹配的pcb或迭代到NULL。</p>
<p>如果pcb匹配，判断上一次是否匹配到pcb，如果是，那么调用sbappendaddr提交数据报到上一次的接收队列，并唤醒因为接收队列而阻塞的进程，之后使用last缓存指针保存pcb。</p>
<p>如果last指针为NULL，说明这是第一次匹配到pcb，那就用last保存该pcb，并进行一次是否结束迭代的判断。</p>
<p>但是在提交之前，我们需要拷贝一个副本，</p>
<p>sbappendaddr函数执行成功后会返回1，也就是说，提交数据报成功后就会唤醒阻塞进程。如果返回的是0，说明提交失败，这是因为缓冲区已满导致的问题，所以需要释放mbuf链。除此之外，该函数还会释放mbuf链，但是考虑到我们是多播或广播，可能不是最后一次提交，所以我们需要使用m_copy备份，并使用变量n保存地址，然后提交给接收队列。</p>
<p>这部分程序的精髓在于提交“上一次”，而非“这一次”。如果检查到匹配的pcb就提交数据报，那么我们不得不考虑最后一次可能出现的问题：我们会多留下一个数据报。但是使用“上一次”，当程序运行到这里时，表示前面的循环结束，可以判断是最后一次，因此无需备份，直接使用原始数据报即可。</p>
<p>（这段程序综合考虑了内存的回收释放，对不同情况处理得非常好）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">if (IN_MULTICAST(ntohl(ip-&gt;ip_dst.s_addr)) ||</span><br><span class="line">    in_broadcast(ip-&gt;ip_dst, m-&gt;m_pkthdr.rcvif)) &#123;</span><br><span class="line">	struct socket *last;</span><br><span class="line">	/*</span><br><span class="line">	 * Deliver a multicast or broadcast datagram to *all* sockets</span><br><span class="line">	 * for which the local and remote addresses and ports match</span><br><span class="line">	 * those of the incoming datagram.  This allows more than</span><br><span class="line">	 * one process to receive multi/broadcasts on the same port.</span><br><span class="line">	 * (This really ought to be done for unicast datagrams as</span><br><span class="line">	 * well, but that would cause problems with existing</span><br><span class="line">	 * applications that open both address-specific sockets and</span><br><span class="line">	 * a wildcard socket listening to the same port -- they would</span><br><span class="line">	 * end up receiving duplicates of every unicast datagram.</span><br><span class="line">	 * Those applications open the multiple sockets to overcome an</span><br><span class="line">	 * inadequacy of the UDP socket interface, but for backwards</span><br><span class="line">	 * compatibility we avoid the problem here rather than</span><br><span class="line">	 * fixing the interface.  Maybe 4.5BSD will remedy this?)</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Construct sockaddr format source address.</span><br><span class="line">	 */</span><br><span class="line">	udp_in.sin_port = uh-&gt;uh_sport;</span><br><span class="line">	udp_in.sin_addr = ip-&gt;ip_src;</span><br><span class="line">	m-&gt;m_len -= sizeof (struct udpiphdr);</span><br><span class="line">	m-&gt;m_data += sizeof (struct udpiphdr);</span><br><span class="line">	/*</span><br><span class="line">	 * Locate pcb(s) for datagram.</span><br><span class="line">	 * (Algorithm copied from raw_intr().)</span><br><span class="line">	 */</span><br><span class="line">	last = NULL;</span><br><span class="line">	for (inp = udb.inp_next; inp != &amp;udb; inp = inp-&gt;inp_next) &#123;</span><br><span class="line">		if (inp-&gt;inp_lport != uh-&gt;uh_dport)</span><br><span class="line">			continue;</span><br><span class="line">		if (inp-&gt;inp_laddr.s_addr != INADDR_ANY) &#123;</span><br><span class="line">			if (inp-&gt;inp_laddr.s_addr !=</span><br><span class="line">			    ip-&gt;ip_dst.s_addr)</span><br><span class="line">				continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (inp-&gt;inp_faddr.s_addr != INADDR_ANY) &#123;</span><br><span class="line">			if (inp-&gt;inp_faddr.s_addr !=</span><br><span class="line">			    ip-&gt;ip_src.s_addr ||</span><br><span class="line">			    inp-&gt;inp_fport != uh-&gt;uh_sport)</span><br><span class="line">				continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (last != NULL) &#123;</span><br><span class="line">			struct mbuf *n;</span><br><span class="line"></span><br><span class="line">			if ((n = m_copy(m, 0, M_COPYALL)) != NULL) &#123;</span><br><span class="line">				if (sbappendaddr(&amp;last-&gt;so_rcv,</span><br><span class="line">					(struct sockaddr *)&amp;udp_in,</span><br><span class="line">					n, (struct mbuf *)0) == 0) &#123;</span><br><span class="line">					m_freem(n);</span><br><span class="line">					udpstat.udps_fullsock++;</span><br><span class="line">				&#125; else</span><br><span class="line">					sorwakeup(last);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		last = inp-&gt;inp_socket;</span><br><span class="line">		/*</span><br><span class="line">		 * Don&#x27;t look for additional matches if this one does</span><br><span class="line">		 * not have either the SO_REUSEPORT or SO_REUSEADDR</span><br><span class="line">		 * socket options set.  This heuristic avoids searching</span><br><span class="line">		 * through all pcbs in the common case of a non-shared</span><br><span class="line">		 * port.  It * assumes that an application will never</span><br><span class="line">		 * clear these options after setting them.</span><br><span class="line">		 */</span><br><span class="line">		if ((last-&gt;so_options&amp;(SO_REUSEPORT|SO_REUSEADDR) == 0))</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (last == NULL) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * No matching pcb found; discard datagram.</span><br><span class="line">		 * (No need to send an ICMP Port Unreachable</span><br><span class="line">		 * for a broadcast or multicast datgram.)</span><br><span class="line">		 */</span><br><span class="line">		udpstat.udps_noportbcast++;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">	if (sbappendaddr(&amp;last-&gt;so_rcv, (struct sockaddr *)&amp;udp_in,</span><br><span class="line">	     m, (struct mbuf *)0) == 0) &#123;</span><br><span class="line">		udpstat.udps_fullsock++;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">	sorwakeup(last);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="分用单播数据报"><a href="#分用单播数据报" class="headerlink" title="分用单播数据报"></a>分用单播数据报</h4><p>如果程序执行到这里，说明程序并没有执行多播操作，那么大概率是单播。</p>
<p><strong>维护缓存指针</strong></p>
<p>udp_last_inpcb是上一次接收数据报的端口的控制块指针，维护该指针的依据是许多程序往往具有时间局部性，也就是：经常运行的程序下一次往往也还运行，不经常运行的程序下一次大概率不会运行。</p>
<p><strong>迭代全部端口</strong></p>
<p>判断缓存指针指向的是不是现在要找的控制块，如果不是，就调用in_pcblookup函数迭代全部端口。</p>
<p><strong>生成ICMP不可达错误</strong></p>
<p>如果inp为NULL，说明没有找到端口，那么需要生成ICMP错误报告消息。</p>
<p><strong>小结</strong></p>
<p>虽然据TCP&#x2F;IP卷二中描述，udp_last_inpcb其实没什么用，但笔者看来这里的程序相当巧妙，能从中感受到作者对时间局部性与空间局部性的考虑。inp被复用进行程序流控制，例如inp为NULL时，这说明肯定是进行了寻找操作且没有找到，因为赋值缓存指针必定使inp不为NULL，如果inp匹配缓存指针或者是找到符合的端口，那么生成ICMP错误的代码就直接跳过。</p>
<p>inp这个变量使用register关键字修饰，并被反复使用。可以想象它的值第一次被保存在寄存器后，后面的程序只需要反复操作该寄存器，而不用频繁对其他变量取地址并引用，这对于指令预取和流水线机制都是十分有利的，因为寄存器本身就是速度最快的内存。</p>
<p>（整个UDP协议的代码都写得非常巧妙，精简凝练，对变量的复用不仅能体现全部的控制流，还能体现时间局部性）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Locate pcb for datagram.</span><br><span class="line"> */</span><br><span class="line">inp = udp_last_inpcb;</span><br><span class="line">if (inp-&gt;inp_lport != uh-&gt;uh_dport ||</span><br><span class="line">    inp-&gt;inp_fport != uh-&gt;uh_sport ||</span><br><span class="line">    inp-&gt;inp_faddr.s_addr != ip-&gt;ip_src.s_addr ||</span><br><span class="line">    inp-&gt;inp_laddr.s_addr != ip-&gt;ip_dst.s_addr) &#123;</span><br><span class="line">	inp = in_pcblookup(&amp;udb, ip-&gt;ip_src, uh-&gt;uh_sport,</span><br><span class="line">	    ip-&gt;ip_dst, uh-&gt;uh_dport, INPLOOKUP_WILDCARD);</span><br><span class="line">	if (inp)</span><br><span class="line">		udp_last_inpcb = inp;</span><br><span class="line">	udpstat.udpps_pcbcachemiss++;</span><br><span class="line">&#125;</span><br><span class="line">if (inp == 0) &#123;</span><br><span class="line">	udpstat.udps_noport++;</span><br><span class="line">	if (m-&gt;m_flags &amp; (M_BCAST | M_MCAST)) &#123;</span><br><span class="line">		udpstat.udps_noportbcast++;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">	*ip = save_ip;</span><br><span class="line">	ip-&gt;ip_len += iphlen;</span><br><span class="line">	icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_PORT, 0, 0);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="单播提交数据报给对应端口"><a href="#单播提交数据报给对应端口" class="headerlink" title="单播提交数据报给对应端口"></a>单播提交数据报给对应端口</h4><p>程序执行到这里都没有返回，说明并不是多播，但肯定是匹配了上一次的控制块或者是找到了控制块，那么是单播。</p>
<p><strong>返回源站IP地址和端口</strong></p>
<p>还记得我们在应用层定义的sockaddr_in变量吗？在这里会把IP地址和端口保存到这个变量中。</p>
<p><strong>返回控制信息</strong></p>
<p>如果定义了控制选项，那么可以使用udp_saveopt分配一个mbuf缓存控制信息（在这里是IP地址）并返回。</p>
<p><strong>提交数据报到socket的接收队列</strong></p>
<p>这一步可以使用sbappendaddr完成，但是在执行之前，需要修正第一个mbuf，忽略UDP首部和IP首部。提交数据报后，需要使用sorwakeup函数唤醒所有阻塞在接收队列的进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Construct sockaddr format source address.</span><br><span class="line">	 * Stuff source address and datagram in user buffer.</span><br><span class="line">	 */</span><br><span class="line">	udp_in.sin_port = uh-&gt;uh_sport;</span><br><span class="line">	udp_in.sin_addr = ip-&gt;ip_src;</span><br><span class="line">	if (inp-&gt;inp_flags &amp; INP_CONTROLOPTS) &#123;</span><br><span class="line">		struct mbuf **mp = &amp;opts;</span><br><span class="line"></span><br><span class="line">		if (inp-&gt;inp_flags &amp; INP_RECVDSTADDR) &#123;</span><br><span class="line">			*mp = udp_saveopt((caddr_t) &amp;ip-&gt;ip_dst,</span><br><span class="line">			    sizeof(struct in_addr), IP_RECVDSTADDR);</span><br><span class="line">			if (*mp)</span><br><span class="line">				mp = &amp;(*mp)-&gt;m_next;</span><br><span class="line">		&#125;</span><br><span class="line">下面宏条件编译的代码还没有实现，暂时忽略</span><br><span class="line">#ifdef notyet</span><br><span class="line">		/* options were tossed above */</span><br><span class="line">		if (inp-&gt;inp_flags &amp; INP_RECVOPTS) &#123;</span><br><span class="line">			*mp = udp_saveopt((caddr_t) opts_deleted_above,</span><br><span class="line">			    sizeof(struct in_addr), IP_RECVOPTS);</span><br><span class="line">			if (*mp)</span><br><span class="line">				mp = &amp;(*mp)-&gt;m_next;</span><br><span class="line">		&#125;</span><br><span class="line">		/* ip_srcroute doesn&#x27;t do what we want here, need to fix */</span><br><span class="line">		if (inp-&gt;inp_flags &amp; INP_RECVRETOPTS) &#123;</span><br><span class="line">			*mp = udp_saveopt((caddr_t) ip_srcroute(),</span><br><span class="line">			    sizeof(struct in_addr), IP_RECVRETOPTS);</span><br><span class="line">			if (*mp)</span><br><span class="line">				mp = &amp;(*mp)-&gt;m_next;</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	iphlen += sizeof(struct udphdr);</span><br><span class="line">	m-&gt;m_len -= iphlen;</span><br><span class="line">	m-&gt;m_pkthdr.len -= iphlen;</span><br><span class="line">	m-&gt;m_data += iphlen;</span><br><span class="line">	if (sbappendaddr(&amp;inp-&gt;inp_socket-&gt;so_rcv, (struct sockaddr *)&amp;udp_in,</span><br><span class="line">	    m, opts) == 0) &#123;</span><br><span class="line">		udpstat.udps_fullsock++;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">	sorwakeup(inp-&gt;inp_socket);</span><br><span class="line">	return;</span><br><span class="line">bad:</span><br><span class="line">	m_freem(m);</span><br><span class="line">	if (opts)</span><br><span class="line">		m_freem(opts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UDP/" rel="tag">UDP</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/02/17/IP%E5%8D%8F%E8%AE%AE/">IP协议</a><a class="next" href="/2025/02/05/%E8%93%9D%E7%89%99%E6%9C%8D%E5%8A%A1/">蓝牙服务</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/compiler/" style="font-size: 15px;">compiler</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/RTOS/" style="font-size: 15px;">RTOS</a> <a href="/tags/TCP-IP-stack/" style="font-size: 15px;">TCP/IP stack</a> <a href="/tags/UDP/" style="font-size: 15px;">UDP</a> <a href="/tags/C-language/" style="font-size: 15px;">C language</a> <a href="/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/" style="font-size: 15px;">虚函数表</a> <a href="/tags/c-flow/" style="font-size: 15px;">c flow</a> <a href="/tags/linux-kernel/" style="font-size: 15px;">linux kernel</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 15px;">内存</a> <a href="/tags/Embedded-RTOS/" style="font-size: 15px;">Embedded RTOS</a> <a href="/tags/c-language/" style="font-size: 15px;">c language</a> <a href="/tags/C-lauguage/" style="font-size: 15px;">C lauguage</a> <a href="/tags/compilers/" style="font-size: 15px;">compilers</a> <a href="/tags/data-struct/" style="font-size: 15px;">data struct</a> <a href="/tags/ble/" style="font-size: 15px;">ble</a> <a href="/tags/IP/" style="font-size: 15px;">IP</a> <a href="/tags/cortex-A7/" style="font-size: 15px;">cortex A7</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/16/ebpf%E6%8A%80%E6%9C%AF/">ebpf技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/21/armCA7%E8%99%9A%E6%8B%9F%E5%8C%96/">armCA7虚拟化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/14/cortex-A7%E6%9E%B6%E6%9E%84/">cortex-A7架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/14/%E5%9C%A8imx6ull-cortex-A7-%E4%B8%8A%E8%BF%90%E8%A1%8CSKRTOS/">在imx6ull(cortex-A7)上运行SKRTOS</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/27/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/">代码设计:面向对象和模块化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/24/buf%E7%BB%93%E6%9E%84/">buf结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/17/IP%E5%8D%8F%E8%AE%AE/">IP协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/08/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/05/%E8%93%9D%E7%89%99%E6%9C%8D%E5%8A%A1/">蓝牙服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/19/TCP%E5%8D%8F%E8%AE%AE%E4%B8%80/">TCP协议一</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>