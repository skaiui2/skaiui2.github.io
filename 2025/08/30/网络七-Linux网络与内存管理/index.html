<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>网络七:Linux网络与内存管理 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">网络七:Linux网络与内存管理</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">网络七:Linux网络与内存管理</h1><div class="post-meta">2025-08-30</div><div class="post-content"><p>skaiuijing</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>没有引言就是一种引言。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>笔者最近在看一些哲学书籍，来个哲学范式的开头：</p>
<p>存在永远不可能是静态的、孤立的。所以海德格尔在存在与时间一书中说：<strong>存在的意义是去存在</strong>。</p>
<p>在本篇的开始，笔者想向各位说明本篇要说明的一种存在，但是这种存在本身又并非静态的存在，而是此在“去”而形成的存在。</p>
<p>正因为这种存在难以描述且不可捉摸，因此笔者也不知道如何描述这种存在，但这种存在具有生命力，而事物的生命力只在其动态瞬间显现。</p>
<p>总而言之，本篇描述的是协议栈的动态过程，即协议栈本身与内存等模块的动态交互，而并不单单局限于某个静态的题材本身，通过这种动态的过程，我们得以窥见其存在。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>Linux内核的伙伴算法、slab分配器这些，网上的教程已经讲得很多了，笔者就不过多赘述了。</p>
<p>我们关心的重点永远是协议栈，而不是内存的管理算法是否高效。</p>
<p>换而言之，协议栈如何与内存交互，从而显现其存在与作为？</p>
<p>但是我们有一个问题需要解决，</p>
<p>内存从何而来？</p>
<h2 id="数据包的内存从何而来？"><a href="#数据包的内存从何而来？" class="headerlink" title="数据包的内存从何而来？"></a>数据包的内存从何而来？</h2><p>在前文，我们介绍了数据包接收的过程，提到了ringbuf，我们知道内核协议栈接收数据包时会写入ringbuf，但是，是把数据写入到了ringbuf了吗？</p>
<p>其实不是，ringbuf中的只是指针（entry），真正的数据并不在ringbuf中。</p>
<p>以intel的e1000网卡为例：</p>
<p>1.在 <code>e1000_alloc_rx_buffers()</code> 中，驱动分配了 <code>skb</code>，并将 <code>skb-&gt;data</code> 映射为 DMA 地址。</p>
<p>2.网卡收到数据包后，通过 DMA 写入 <code>skb-&gt;data</code> 指向的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * e1000_alloc_rx_buffers - Replace used receive buffers</span><br><span class="line"> * @rx_ring: Rx descriptor ring</span><br><span class="line"> * @cleaned_count: number to reallocate</span><br><span class="line"> * @gfp: flags for allocation</span><br><span class="line"> **/</span><br><span class="line">static void e1000_alloc_rx_buffers(struct e1000_ring *rx_ring,</span><br><span class="line">				   int cleaned_count, gfp_t gfp)</span><br><span class="line">&#123;</span><br><span class="line">	struct e1000_adapter *adapter = rx_ring-&gt;adapter;</span><br><span class="line">	struct net_device *netdev = adapter-&gt;netdev;</span><br><span class="line">	struct pci_dev *pdev = adapter-&gt;pdev;</span><br><span class="line">	union e1000_rx_desc_extended *rx_desc;</span><br><span class="line">	struct e1000_buffer *buffer_info;</span><br><span class="line">	struct sk_buff *skb;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	unsigned int bufsz = adapter-&gt;rx_buffer_len;</span><br><span class="line"></span><br><span class="line">	i = rx_ring-&gt;next_to_use;</span><br><span class="line">	//指向下一个entry</span><br><span class="line">	buffer_info = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">	//复用或者是分配skb，但是复用是怎么来的呢？让我们后面揭晓</span><br><span class="line">	while (cleaned_count--) &#123;</span><br><span class="line">		skb = buffer_info-&gt;skb;</span><br><span class="line">		if (skb) &#123;</span><br><span class="line">			skb_trim(skb, 0);</span><br><span class="line">			goto map_skb;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//分配skb及内存空间</span><br><span class="line">		skb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);</span><br><span class="line">		if (!skb) &#123;</span><br><span class="line">			/* Better luck next round */</span><br><span class="line">			adapter-&gt;alloc_rx_buff_failed++;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buffer_info-&gt;skb = skb;</span><br><span class="line">map_skb:</span><br><span class="line">		//将 skb-&gt;data 指向的虚拟地址映射为物理地址，供网卡 DMA 写入</span><br><span class="line">		buffer_info-&gt;dma = dma_map_single(&amp;pdev-&gt;dev, skb-&gt;data,</span><br><span class="line">						  adapter-&gt;rx_buffer_len,</span><br><span class="line">						  DMA_FROM_DEVICE);</span><br><span class="line">		if (dma_mapping_error(&amp;pdev-&gt;dev, buffer_info-&gt;dma)) &#123;</span><br><span class="line">			dev_err(&amp;pdev-&gt;dev, &quot;Rx DMA map failed\n&quot;);</span><br><span class="line">			adapter-&gt;rx_dma_failed++;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		//获取当前 entry 的 RX 描述符,并将刚刚映射好的 DMA 地址写入 buffer_addr 字段，告诉网卡“新数据请写到这里”</span><br><span class="line">		rx_desc = E1000_RX_DESC_EXT(*rx_ring, i);</span><br><span class="line">		//这就是ringbuf的实际entry</span><br><span class="line">		rx_desc-&gt;read.buffer_addr = cpu_to_le64(buffer_info-&gt;dma);</span><br><span class="line"></span><br><span class="line">		if (unlikely(!(i &amp; (E1000_RX_BUFFER_WRITE - 1)))) &#123;</span><br><span class="line">			/* Force memory writes to complete before letting h/w</span><br><span class="line">			 * know there are new descriptors to fetch.  (Only</span><br><span class="line">			 * applicable for weak-ordered memory model archs,</span><br><span class="line">			 * such as IA-64).</span><br><span class="line">			 */</span><br><span class="line">			wmb();</span><br><span class="line">			if (adapter-&gt;flags2 &amp; FLAG2_PCIM2PCI_ARBITER_WA)</span><br><span class="line">				e1000e_update_rdt_wa(rx_ring, i);</span><br><span class="line">			else</span><br><span class="line">				writel(i, rx_ring-&gt;tail);</span><br><span class="line">		&#125;</span><br><span class="line">		//移动到下一个 ring entry</span><br><span class="line">		i++;</span><br><span class="line">		if (i == rx_ring-&gt;count)</span><br><span class="line">			i = 0;</span><br><span class="line">		buffer_info = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rx_ring-&gt;next_to_use = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，我们总结如下：</p>
<p>网卡初始化时的工作：</p>
<p>1.<strong>为每个接收描述符分配一个</strong> <code>sk_buff</code></p>
<p>2.<strong>将</strong> <code>skb-&gt;data</code> <strong>的物理地址映射为 DMA 地址</strong></p>
<p>3.<strong>将 DMA 地址写入对应的接收描述符（Rx descriptor）</strong></p>
<p>4.<strong>更新网卡硬件的接收环形缓冲区，使其准备好接收下一个数据包</strong></p>
<p>这一切似乎看起来都很合理，但是，有一个意外的参数：<strong>cleaned_count</strong>。它正是串联了整个协议栈的sk_buff内存起始于结束相关的一个参数。</p>
<p><strong>那么内存究竟从何而来呢？</strong></p>
<p>这其实就是伙伴算法、slab分配器的事情了，但是，不管我们是使用alloc_page还是什么，我们的目的其实就是为了得到一块内存，而得到<strong>内存本身</strong>是<strong>内存本身的事情</strong>，而不是协议栈与内存<strong>交互的事情</strong>，因为协议栈只关心如何得到一块内存。</p>
<p>得到内存本身，在乎的是得到内存本身的过程是否高效。</p>
<p>得到一块内存，仅仅在乎是否能得到一块内存。</p>
<p>协议栈子系统与内存子系统的交流就是这么简单。</p>
<h2 id="数据包与内存的起始与结束"><a href="#数据包与内存的起始与结束" class="headerlink" title="数据包与内存的起始与结束"></a>数据包与内存的起始与结束</h2><p>在黑格尔的小逻辑学里，任何事物本身逻辑是自洽的，也就是说，不管事情如何向着高处螺旋式发展，最终，终点也必定会成为起点。</p>
<p>而数据包也是一样。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>驱动开机&#x2F;重启时，<code>e1000e_setup_rx_resources()</code> 循环调用 <code>e1000_alloc_rx_buffers()</code>，给所有 entry 填满 skb-&gt;data映射的DMA 地址</p>
<h3 id="结束时"><a href="#结束时" class="headerlink" title="结束时"></a>结束时</h3><p><code>e1000_clean_rx_irq()</code> 处理完若干个 entry 之后，会带着 <code>cleaned_count</code> 再次调用 <code>e1000_alloc_rx_buffers()</code></p>
<p>这里再次给用掉的 entry 重新分配 skb 并写入 descriptor</p>
<p>这样每次网卡想写包时，descriptor 都已经指向了一块 sk_buff 的 data 缓冲区。</p>
<p>这样，sk_buff分配的结束，却是sk_buff新一轮分配的开始。</p>
<p>sk_buff分配的结束，却是进入协议栈的开始，e1000_clean_rx_irq会将数据包送入协议栈。</p>
<h2 id="数据包如何被送入协议栈？"><a href="#数据包如何被送入协议栈？" class="headerlink" title="数据包如何被送入协议栈？"></a>数据包如何被送入协议栈？</h2><p><strong>buffer_info</strong> 就是驱动在 RX ring 结构里维护的一块“元数据”数组，用来记录每个 descriptor（ring entry）对应的实际接收缓冲区（sk_buff 或 page fragment）以及它的 DMA 映射信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * e1000_clean_rx_irq - Send received data up the network stack</span><br><span class="line"> * @rx_ring: Rx descriptor ring</span><br><span class="line"> * @work_done: output parameter for indicating completed work</span><br><span class="line"> * @work_to_do: how many packets we can clean</span><br><span class="line"> *</span><br><span class="line"> * the return value indicates whether actual cleaning was done, there</span><br><span class="line"> * is no guarantee that everything was cleaned</span><br><span class="line"> **/</span><br><span class="line">static bool e1000_clean_rx_irq(struct e1000_ring *rx_ring, int *work_done,</span><br><span class="line">			       int work_to_do)</span><br><span class="line">&#123;</span><br><span class="line">	//初始化指针与状态,rx_desc 是网卡写入的描述符，包含状态位和数据长度</span><br><span class="line">	struct e1000_adapter *adapter = rx_ring-&gt;adapter;</span><br><span class="line">	struct net_device *netdev = adapter-&gt;netdev;</span><br><span class="line">	struct pci_dev *pdev = adapter-&gt;pdev;</span><br><span class="line">	struct e1000_hw *hw = &amp;adapter-&gt;hw;</span><br><span class="line">	union e1000_rx_desc_extended *rx_desc, *next_rxd;</span><br><span class="line">	struct e1000_buffer *buffer_info, *next_buffer;</span><br><span class="line">	u32 length, staterr;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	//清理了多少个的同时也意味着要重新构造多少个</span><br><span class="line">	int cleaned_count = 0;</span><br><span class="line">	bool cleaned = false;</span><br><span class="line">	unsigned int total_rx_bytes = 0, total_rx_packets = 0;</span><br><span class="line"></span><br><span class="line">	i = rx_ring-&gt;next_to_clean;</span><br><span class="line">	rx_desc = E1000_RX_DESC_EXT(*rx_ring, i);</span><br><span class="line">	staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);</span><br><span class="line">	buffer_info = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">	while (staterr &amp; E1000_RXD_STAT_DD) &#123;</span><br><span class="line">		struct sk_buff *skb;</span><br><span class="line"></span><br><span class="line">		if (*work_done &gt;= work_to_do)</span><br><span class="line">			break;</span><br><span class="line">		(*work_done)++;</span><br><span class="line">		dma_rmb();	/* read descriptor and rx_buffer_info after status DD */</span><br><span class="line">		//获取skb</span><br><span class="line">		skb = buffer_info-&gt;skb;</span><br><span class="line">		buffer_info-&gt;skb = NULL;</span><br><span class="line"></span><br><span class="line">		prefetch(skb-&gt;data - NET_IP_ALIGN);</span><br><span class="line"></span><br><span class="line">		i++;</span><br><span class="line">		if (i == rx_ring-&gt;count)</span><br><span class="line">			i = 0;</span><br><span class="line">		next_rxd = E1000_RX_DESC_EXT(*rx_ring, i);</span><br><span class="line">		prefetch(next_rxd);</span><br><span class="line"></span><br><span class="line">		next_buffer = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">		cleaned = true;</span><br><span class="line">		cleaned_count++;</span><br><span class="line">		//清理DMA映射</span><br><span class="line">		dma_unmap_single(&amp;pdev-&gt;dev, buffer_info-&gt;dma,</span><br><span class="line">				 adapter-&gt;rx_buffer_len, DMA_FROM_DEVICE);</span><br><span class="line">		buffer_info-&gt;dma = 0;</span><br><span class="line">		//获取数据长度</span><br><span class="line">		length = le16_to_cpu(rx_desc-&gt;wb.upper.length);</span><br><span class="line"></span><br><span class="line">		/* !EOP means multiple descriptors were used to store a single</span><br><span class="line">		 * packet, if that&#x27;s the case we need to toss it.  In fact, we</span><br><span class="line">		 * need to toss every packet with the EOP bit clear and the</span><br><span class="line">		 * next frame that _does_ have the EOP bit set, as it is by</span><br><span class="line">		 * definition only a frame fragment</span><br><span class="line">		 */</span><br><span class="line">		if (unlikely(!(staterr &amp; E1000_RXD_STAT_EOP)))</span><br><span class="line">			adapter-&gt;flags2 |= FLAG2_IS_DISCARDING;</span><br><span class="line"></span><br><span class="line">		if (adapter-&gt;flags2 &amp; FLAG2_IS_DISCARDING) &#123;</span><br><span class="line">			/* All receives must fit into a single buffer */</span><br><span class="line">			e_dbg(&quot;Receive packet consumed multiple buffers\n&quot;);</span><br><span class="line">			/* recycle */</span><br><span class="line">			buffer_info-&gt;skb = skb;</span><br><span class="line">			if (staterr &amp; E1000_RXD_STAT_EOP)</span><br><span class="line">				adapter-&gt;flags2 &amp;= ~FLAG2_IS_DISCARDING;</span><br><span class="line">			goto next_desc;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (unlikely((staterr &amp; E1000_RXDEXT_ERR_FRAME_ERR_MASK) &amp;&amp;</span><br><span class="line">			     !(netdev-&gt;features &amp; NETIF_F_RXALL))) &#123;</span><br><span class="line">			/* recycle */</span><br><span class="line">			buffer_info-&gt;skb = skb;</span><br><span class="line">			goto next_desc;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* adjust length to remove Ethernet CRC */</span><br><span class="line">		if (!(adapter-&gt;flags2 &amp; FLAG2_CRC_STRIPPING)) &#123;</span><br><span class="line">			/* If configured to store CRC, don&#x27;t subtract FCS,</span><br><span class="line">			 * but keep the FCS bytes out of the total_rx_bytes</span><br><span class="line">			 * counter</span><br><span class="line">			 */</span><br><span class="line">			if (netdev-&gt;features &amp; NETIF_F_RXFCS)</span><br><span class="line">				total_rx_bytes -= 4;</span><br><span class="line">			else</span><br><span class="line">				length -= 4;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		total_rx_bytes += length;</span><br><span class="line">		total_rx_packets++;</span><br><span class="line"></span><br><span class="line">		/* code added for copybreak, this should improve</span><br><span class="line">		 * performance for small packets with large amounts</span><br><span class="line">		 * of reassembly being done in the stack</span><br><span class="line">		 */</span><br><span class="line">		if (length &lt; copybreak) &#123;</span><br><span class="line">			//长度过小</span><br><span class="line">			struct sk_buff *new_skb =</span><br><span class="line">				//如果数据包小于256字节，分配小包专用的skb</span><br><span class="line">				napi_alloc_skb(&amp;adapter-&gt;napi, length);</span><br><span class="line">			if (new_skb) &#123;</span><br><span class="line">				//拷贝数据（含 NET_IP_ALIGN 前缀对齐）</span><br><span class="line">				skb_copy_to_linear_data_offset(new_skb,</span><br><span class="line">							       -NET_IP_ALIGN,</span><br><span class="line">							       (skb-&gt;data -</span><br><span class="line">								NET_IP_ALIGN),</span><br><span class="line">							       (length +</span><br><span class="line">								NET_IP_ALIGN));</span><br><span class="line">				/* save the skb in buffer_info as good */看看，这里又把大的skb重新放回去了</span><br><span class="line">				buffer_info-&gt;skb = skb;</span><br><span class="line">				//使用小包</span><br><span class="line">				skb = new_skb;</span><br><span class="line">			&#125;</span><br><span class="line">			/* else just continue with the old one */</span><br><span class="line">		&#125;</span><br><span class="line">		/* end copybreak code */</span><br><span class="line">		skb_put(skb, length);</span><br><span class="line"></span><br><span class="line">		/* Receive Checksum Offload */</span><br><span class="line">		e1000_rx_checksum(adapter, staterr, skb);</span><br><span class="line"></span><br><span class="line">		e1000_rx_hash(netdev, rx_desc-&gt;wb.lower.hi_dword.rss, skb);</span><br><span class="line">		//提交给协议栈</span><br><span class="line">		e1000_receive_skb(adapter, netdev, skb, staterr,</span><br><span class="line">				  rx_desc-&gt;wb.upper.vlan);</span><br><span class="line"></span><br><span class="line">next_desc:</span><br><span class="line">		rx_desc-&gt;wb.upper.status_error &amp;= cpu_to_le32(~0xFF);</span><br><span class="line"></span><br><span class="line">		/* return some buffers to hardware, one at a time is too slow */</span><br><span class="line">		if (cleaned_count &gt;= E1000_RX_BUFFER_WRITE) &#123;</span><br><span class="line">			adapter-&gt;alloc_rx_buf(rx_ring, cleaned_count,</span><br><span class="line">					      GFP_ATOMIC);</span><br><span class="line">			cleaned_count = 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* use prefetched values */</span><br><span class="line">		rx_desc = next_rxd;</span><br><span class="line">		buffer_info = next_buffer;</span><br><span class="line"></span><br><span class="line">		staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);</span><br><span class="line">	&#125;</span><br><span class="line">	rx_ring-&gt;next_to_clean = i;</span><br><span class="line"></span><br><span class="line">	cleaned_count = e1000_desc_unused(rx_ring);</span><br><span class="line">	if (cleaned_count)</span><br><span class="line">		adapter-&gt;alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);</span><br><span class="line"></span><br><span class="line">	adapter-&gt;total_rx_bytes += total_rx_bytes;</span><br><span class="line">	adapter-&gt;total_rx_packets += total_rx_packets;</span><br><span class="line">	return cleaned;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小包优化"><a href="#小包优化" class="headerlink" title="小包优化"></a>小包优化</h3><p>在检测到是小包后，仅仅设置了这么一句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer_info-&gt;skb = skb;</span><br></pre></td></tr></table></figure>

<p>那么这个大的skb到底是怎么被复用的呢？</p>
<p>还记得我们的e1000_alloc_rx_buffers开头分配skb有复用吗？</p>
<p>其实就在于这里了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void e1000_alloc_rx_buffers(struct e1000_ring *rx_ring,</span><br><span class="line">				   int cleaned_count, gfp_t gfp)</span><br><span class="line">&#123;</span><br><span class="line">	省略一堆</span><br><span class="line">	//这里的复用就包含了这个大的skb（相对于小包来说太大了）</span><br><span class="line">	while (cleaned_count--) &#123;</span><br><span class="line">		skb = buffer_info-&gt;skb;</span><br><span class="line">		if (skb) &#123;</span><br><span class="line">			skb_trim(skb, 0);</span><br><span class="line">			goto map_skb;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在对内容进行总结：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Aa(驱动初始化时调用alloc_rx_buffers方法分配rinfbuf)--&gt;Ab(完成数据包分配及DMA映射)</span><br><span class="line">Ba(网卡传输数据)--&gt;Bb(直接DMA找到ringbuf映射的地址写入数据)</span><br><span class="line">Ca(ksoftirqd进程工作)--&gt;Cc(调用e1000_clean_rx_irq)--&gt;Cb(把数据包丢给上层并复用skb)</span><br></pre></td></tr></table></figure>

<p>ringbuf的实质是什么呢？其实就是一个存放指针及状态的环形数组而已。但是，它让分配内存与分配数据包实现了解耦。这就是中间件的哲学设计所在。</p>
<p>而在FreeBSD中，是直接使用队列完成的。数据包的内存也不并不是全是预先分配的，而是按需动态分配的，当然，虽然也有cluster这样的存在。</p>
<p>在FreeBSD中，buf结构有四种，并不都像Linux这样直接使用指针，而是使用混合策略。</p>
<p>其中有一种mbuf，是直接使用c语言的动态数组，把数据包内容复制到mbuf后面，然后再转交给应用层的。而使用cluster时，其实与Linux大差不差。</p>
<p>关于内核与内存的交互，是如何进行性能优化的，其实就两点：</p>
<ol>
<li><p><strong>一个是使用指针及中间数据结构，避免拷贝。</strong></p>
</li>
<li><p><strong>另一个就是：根据实际情况合理复用内存。</strong></p>
</li>
</ol>
<p>在实际开发中，我们可以通过ethtool等工具调整ringbuf大小，优化网络性能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -G &lt;iface&gt; rx &lt;SIZE&gt; tx &lt;SIZE&gt;</span><br></pre></td></tr></table></figure>

<p>我们也可以控制软中断接收队列最大积压包数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 8000 &gt; /proc/sys/net/core/netdev_max_backlog</span><br></pre></td></tr></table></figure>

<p>也可以调整中断频率，这样就可以一次性处理多个包。</p>
<p>就留给读者慢慢理解了，笔者已经讲完了。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/net/" rel="tag">net</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/08/31/%E7%BD%91%E7%BB%9C%E5%85%AB%EF%BC%9ALinux%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%86%85%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E6%8B%B7%E8%B4%9D/">网络八：Linux网络与内存(数据包与拷贝)</a><a class="next" href="/2025/08/28/%E7%B2%BE%E7%A5%9E%E7%8E%B0%E8%B1%A1%E5%AD%A6%E4%B8%80/">精神现象学一</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/compiler/" style="font-size: 15px;">compiler</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/RTOS/" style="font-size: 15px;">RTOS</a> <a href="/tags/TCP-IP-stack/" style="font-size: 15px;">TCP/IP stack</a> <a href="/tags/UDP/" style="font-size: 15px;">UDP</a> <a href="/tags/C-language/" style="font-size: 15px;">C language</a> <a href="/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/" style="font-size: 15px;">虚函数表</a> <a href="/tags/c-flow/" style="font-size: 15px;">c flow</a> <a href="/tags/linux-kernel/" style="font-size: 15px;">linux kernel</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 15px;">内存</a> <a href="/tags/Embedded-RTOS/" style="font-size: 15px;">Embedded RTOS</a> <a href="/tags/c-language/" style="font-size: 15px;">c language</a> <a href="/tags/C-lauguage/" style="font-size: 15px;">C lauguage</a> <a href="/tags/compilers/" style="font-size: 15px;">compilers</a> <a href="/tags/data-struct/" style="font-size: 15px;">data struct</a> <a href="/tags/ble/" style="font-size: 15px;">ble</a> <a href="/tags/IP/" style="font-size: 15px;">IP</a> <a href="/tags/cortex-A7/" style="font-size: 15px;">cortex A7</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a> <a href="/tags/tc/" style="font-size: 15px;">tc</a> <a href="/tags/early-demux/" style="font-size: 15px;">early demux</a> <a href="/tags/tags/" style="font-size: 15px;">tags</a> <a href="/tags/%E5%93%B2%E5%AD%A6/" style="font-size: 15px;">哲学</a> <a href="/tags/net/" style="font-size: 15px;">net</a> <a href="/tags/memory/" style="font-size: 15px;">memory</a> <a href="/tags/ARP/" style="font-size: 15px;">ARP</a> <a href="/tags/eBPF/" style="font-size: 15px;">eBPF</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/09/01/%E7%BD%91%E7%BB%9C%E4%B9%9D-Linux%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%86%85%E5%AD%98%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E6%8B%B7%E8%B4%9D/">网络九:Linux网络与内存应用层的拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/31/%E7%BD%91%E7%BB%9C%E5%85%AB%EF%BC%9ALinux%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%86%85%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%8E%E6%8B%B7%E8%B4%9D/">网络八：Linux网络与内存(数据包与拷贝)</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/30/%E7%BD%91%E7%BB%9C%E4%B8%83-Linux%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">网络七:Linux网络与内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/28/%E7%B2%BE%E7%A5%9E%E7%8E%B0%E8%B1%A1%E5%AD%A6%E4%B8%80/">精神现象学一</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/27/%E7%BD%91%E7%BB%9C%E5%85%AD-eBPF%E4%B8%8EARP%E6%AC%BA%E9%AA%97/">网络六:eBPF与ARP欺骗</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/27/%E7%BD%91%E7%BB%9C%E4%BA%94-%E5%AE%9E%E7%8E%B0ARP/">网络五:实现ARP</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/26/%E7%BD%91%E7%BB%9C%E5%9B%9B-%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%9E%B6%E6%9E%84/">网络四:协议栈与流水线架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/25/linux%E7%BD%91%E7%BB%9C%E4%B9%8Bdemux/">linux网络之demux</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/24/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AE%97%E6%B3%95/">内存管理算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/23/%E7%BD%91%E7%BB%9C%E4%B8%89-eBPF%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%8C%85/">网络三:eBPF解析数据包</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>