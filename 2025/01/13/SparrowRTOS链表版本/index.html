<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>SparrowRTOS链表版本 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SparrowRTOS链表版本</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SparrowRTOS链表版本</h1><div class="post-meta">2025-01-13</div><div class="post-content"><p>skaiuijing</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Sparrow RTOS是笔者之前写的一个极简性RTOS，初代版本只有400行，后面笔者又添加了消息队列、信号量、互斥锁三种IPC机制，使之成为一个较完整、堪用的内核，初代版本以简洁为主，使用数组和表作为任务挂载的抽象数据结构，对数表版本的Sparrow RTOS总结如下：</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>由于数组和表的限制，该版本并不支持同优先级和时间片功能，设计互斥锁时也受到一定影响，而且最大只支持32个任务，有许多不便之处。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>使用数表存储任务，对任务的挂载以位操作和下标操作为主，内核简洁小巧，执行效率高，适用于任务较少、硬件资源少的情况。</p>
<h2 id="链表版本内核的设计"><a href="#链表版本内核的设计" class="headerlink" title="链表版本内核的设计"></a>链表版本内核的设计</h2><p>使用链表作为任务挂载的数据结构，能够实现同优先级、时间片等功能，对任务对象的操作也更加灵活。</p>
<h3 id="链表设计"><a href="#链表设计" class="headerlink" title="链表设计"></a>链表设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Ab(链表头部)--双向链表--&gt;Ac(链表头节点)--双向链表--&gt;Ad(链表节点)--双向链表--&gt;Ae(链表尾节点)</span><br><span class="line">Ae--双向链表--&gt;Ac</span><br><span class="line"></span><br><span class="line">Ab--&gt;Ae</span><br></pre></td></tr></table></figure>



<p>任务链表由头部节点和任务节点两部分组成，头部会指向头节点和尾节点，头节点到尾节点之间会形成一个环路。</p>
<h3 id="就绪列表设计"><a href="#就绪列表设计" class="headerlink" title="就绪列表设计"></a>就绪列表设计</h3><p>链表简化设计如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Aa(链表数组Index)</span><br><span class="line">Ba(链表头部Index1)--&gt;Bb(任务节点)</span><br><span class="line">Ca(链表头部Index2)--&gt;Cb(任务节点)</span><br><span class="line">Da(链表头部Index3)--&gt;Db(任务节点)</span><br></pre></td></tr></table></figure>

<p>实际设计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Ab(链表头部Index1)--双向链表--&gt;Ac(任务头节点)--双向链表--&gt;Ad(任务节点)--双向链表--&gt;Ae(任务尾节点)</span><br><span class="line">Ae--双向链表--&gt;Ac</span><br><span class="line">Ab--&gt;Ae</span><br><span class="line"></span><br><span class="line">Bb(链表头部Index2)--双向链表--&gt;Bc(任务头节点)--双向链表--&gt;Bd(任务节点)--双向链表--&gt;Be(任务尾节点)</span><br><span class="line">Be--双向链表--&gt;Bc</span><br><span class="line">Bb--&gt;Be</span><br><span class="line"></span><br><span class="line">Cb(链表头部Index3)--双向链表--&gt;Cc(任务头节点)--双向链表--&gt;Cd(任务节点)--双向链表--&gt;Ce(任务尾节点)</span><br><span class="line">Ce--双向链表--&gt;Cc</span><br><span class="line">Cb--&gt;Ce</span><br></pre></td></tr></table></figure>



<p>任务节点通过链表进行挂载，那么怎么找到任务对象的起始地址呢？</p>
<p>请读者想一想，任务对象的成员都是已知的，所以我们完全可以用链表节点的地址减去前面的成员的地址，就能得到任务对象的起始地址，然后再把起始地址类型转换为任务对象指针。</p>
<p>基于这个思想，其实我们是可以在面向对象的语言中修改私有属性的（如果这门语言支持指针这种直接操作内存的语法的话）。</p>
<p>不过一个个算还是太麻烦了，我们可以直接使用宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//get father struct address</span><br><span class="line">//how to use it:struct parent *parent_ptr = container_of(child_ptr, struct parent, child)</span><br><span class="line">#define container_of(ptr, type, member) \</span><br><span class="line">    ((type *)((char *)(ptr) - offsetof(type, member)))</span><br></pre></td></tr></table></figure>

<p>这样就可以直接通过链表找到任务对象起始地址了。</p>
<p>相对于初步的Sparrow RTOS，链表版本的功能增加如下,增加了一个TimeSlice，也就是时间片功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">void xTaskCreate( TaskFunction_t pxTaskCode,</span><br><span class="line">                  const uint16_t usStackDepth,</span><br><span class="line">                  void * const pvParameters,</span><br><span class="line">                  uint32_t uxPriority,</span><br><span class="line">                  TaskHandle_t * const self,</span><br><span class="line">                  uint8_t TimeSlice)</span><br></pre></td></tr></table></figure>



<h3 id="任务优先级设置"><a href="#任务优先级设置" class="headerlink" title="任务优先级设置"></a>任务优先级设置</h3><p>使用链表数组对应每个优先级，因此我们可以通过设置链表数组的大小来更改支持的优先级范围。不过由于支持同优先级和时间片，因此挂载的任务数量其实是不受限制的（除非内存不够）。</p>
<h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>时间片是针对同优先级的说法，当最高优先级有多个任务时，每个任务会根据自身设置的时间片轮流享有CPU运行时间。</p>
<p>在时钟触发型RTOS中，一个时间片就是两次systick时钟中断之间的响应间隔，在Sparrow RTOS中，默认为1ms。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate(    taskA,</span><br><span class="line">                256,</span><br><span class="line">                NULL,</span><br><span class="line">                3,</span><br><span class="line">                &amp;tcbTask1,</span><br><span class="line">                1</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">xTaskCreate(    taskB,</span><br><span class="line">                256,</span><br><span class="line">                NULL,</span><br><span class="line">                3,</span><br><span class="line">                &amp;tcbTask2,</span><br><span class="line">                3</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于taskA和taskB，当最高优先级为3时，这两个任务会轮流执行，不过taskA只会执行1个时间片，然后就会将CPU执行权交给taskB，taskB会执行三个时间片，然后再将CPU执行权交给taskA，如此反复循环（如果最高优先级一直是3）。</p>
<h3 id="互斥锁设计"><a href="#互斥锁设计" class="headerlink" title="互斥锁设计"></a>互斥锁设计</h3><p>在Sparrow RTOS的数表版本中，互斥锁的优先级反转功能是设置优先级为阻塞任务中最大的那个优先级+1，但是这样会导致浪费优先级，对于可能发生阻塞的任务，我们要确保这些任务的优先级必须设置合理，不然会导致灾难的发生。</p>
<p>但是对于链表版本，由于支持同优先级，因此我们可以设置相同的优先级避免优先级反转现象的发生，而不会占用额外的优先级。</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>由于临界区屏蔽中断的较为粗暴，所以对于简单的加减操作，可以使用内核提供的原子操作，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic_add(a,v),表示*v + a</span><br><span class="line">atomic_inc(v),表示*v自加</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>考虑下面的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void  taskA()&#123;</span><br><span class="line">		a++;</span><br><span class="line">任务切换发生，另一个任务令a++;</span><br><span class="line">		b = a;读取a，但是a的值是错误的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  taskB()&#123;</span><br><span class="line">		a++;</span><br><span class="line">		c = a; a的值是错误的</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们使用A和B两个线程对a进行递增，但是两个线程的递增可能是无效的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(线程1读取counter值等于0)--&gt;B(线程1增加counter值)</span><br><span class="line">B--&gt;C(CPU0写入counter值等于1)</span><br><span class="line">D(线程2读取counter值等于0)--&gt;E(线程2增加counter值)</span><br><span class="line">E--&gt;F(线程1写入counter值等于1)</span><br><span class="line">C--&gt;G(最终counter值等于1)</span><br><span class="line">F--&gt;G</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>原子操作具有return版本,例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = atomic_inc_return(a,v);</span><br></pre></td></tr></table></figure>

<p>其实原子操作不仅可以保证线程操作的原子性，也可以在多CPU条件下保证数据操作的原子性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对Sparrow RTOS链表版本内核的总结，整体来看，链表版本支持更多任务数量和功能，但是执行效率和简洁性不如数表版本，不过二者适用情景不同，根据实际情况选择即可。</p>
<p>笔者本人更喜欢数表版本，只使用了几百行程序就实现了RTOS的基本功能，简洁明了，同时也是一个良好的学习素材。笔者追求的程序风格一直都是模块化、高效、简洁明了，数表版本的内核是非常令笔者得意的，毕竟几千几万行的操作系统内核浩如烟海，几百行的可不多见。</p>
<p>对于学习Sparrow RTOS的读者来说，笔者推荐数表版本的内核，虽然代码量不多，但彻底搞懂并能更改代码可不容易。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Sparrow RTOS将会持续维护更新，不断完善，其实笔者也是有为它添加设备树、驱动框架和网络协议栈这些功能的想法，不过这都是后话了，也许哪天会更新，也许一直没时间做这些，这都是不确定的。不过它的初衷就是一个学习用途的RTOS，而它也确实非常适合这一任务。</p>
<p>最后，笔者真诚希望读者都能在Sparrow RTOS的教程中收获对操作系统的思考与领悟，操作系统的学习之路道阻且长，在海滩拾贝的过程中，希望读者也能收获属于自己的快乐。</p>
<p>以上，与君共勉。</p>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/skaiui2/SKRTOS_sparrow">skaiui2&#x2F;SKRTOS_sparrow: Lightweight rtos inspired by SKRTOS</a></p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RTOS/" rel="tag">RTOS</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/01/19/TCP%E5%8D%8F%E8%AE%AE%E4%B8%80/">TCP协议一</a><a class="next" href="/2025/01/02/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0/">红黑树实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/compiler/" style="font-size: 15px;">compiler</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/RTOS/" style="font-size: 15px;">RTOS</a> <a href="/tags/TCP-IP-stack/" style="font-size: 15px;">TCP/IP stack</a> <a href="/tags/UDP/" style="font-size: 15px;">UDP</a> <a href="/tags/C-language/" style="font-size: 15px;">C language</a> <a href="/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/" style="font-size: 15px;">虚函数表</a> <a href="/tags/c-flow/" style="font-size: 15px;">c flow</a> <a href="/tags/linux-kernel/" style="font-size: 15px;">linux kernel</a> <a href="/tags/%E5%86%85%E5%AD%98/" style="font-size: 15px;">内存</a> <a href="/tags/Embedded-RTOS/" style="font-size: 15px;">Embedded RTOS</a> <a href="/tags/c-language/" style="font-size: 15px;">c language</a> <a href="/tags/C-lauguage/" style="font-size: 15px;">C lauguage</a> <a href="/tags/compilers/" style="font-size: 15px;">compilers</a> <a href="/tags/data-struct/" style="font-size: 15px;">data struct</a> <a href="/tags/ble/" style="font-size: 15px;">ble</a> <a href="/tags/IP/" style="font-size: 15px;">IP</a> <a href="/tags/cortex-A7/" style="font-size: 15px;">cortex A7</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/07/16/ebpf%E6%8A%80%E6%9C%AF/">ebpf技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/21/armCA7%E8%99%9A%E6%8B%9F%E5%8C%96/">armCA7虚拟化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/14/cortex-A7%E6%9E%B6%E6%9E%84/">cortex-A7架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/14/%E5%9C%A8imx6ull-cortex-A7-%E4%B8%8A%E8%BF%90%E8%A1%8CSKRTOS/">在imx6ull(cortex-A7)上运行SKRTOS</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/27/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/">代码设计:面向对象和模块化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/24/buf%E7%BB%93%E6%9E%84/">buf结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/17/IP%E5%8D%8F%E8%AE%AE/">IP协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/08/UDP%E5%8D%8F%E8%AE%AE/">UDP协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/05/%E8%93%9D%E7%89%99%E6%9C%8D%E5%8A%A1/">蓝牙服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/19/TCP%E5%8D%8F%E8%AE%AE%E4%B8%80/">TCP协议一</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>